
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AccessToken
 * 
 */
export type AccessToken = $Result.DefaultSelection<Prisma.$AccessTokenPayload>
/**
 * Model Dinas
 * 
 */
export type Dinas = $Result.DefaultSelection<Prisma.$DinasPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model DokumenProgram
 * 
 */
export type DokumenProgram = $Result.DefaultSelection<Prisma.$DokumenProgramPayload>
/**
 * Model Pengadaan
 * 
 */
export type Pengadaan = $Result.DefaultSelection<Prisma.$PengadaanPayload>
/**
 * Model Tahapan
 * 
 */
export type Tahapan = $Result.DefaultSelection<Prisma.$TahapanPayload>
/**
 * Model TransaksiPengadaan
 * 
 */
export type TransaksiPengadaan = $Result.DefaultSelection<Prisma.$TransaksiPengadaanPayload>
/**
 * Model ProgresTahapan
 * 
 */
export type ProgresTahapan = $Result.DefaultSelection<Prisma.$ProgresTahapanPayload>
/**
 * Model DokumenProgresTahapan
 * 
 */
export type DokumenProgresTahapan = $Result.DefaultSelection<Prisma.$DokumenProgresTahapanPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  gubernur: 'gubernur',
  staff: 'staff',
  staff_master: 'staff_master'
};

export type Role = (typeof Role)[keyof typeof Role]


export const StatusTahapan: {
  on_progress: 'on_progress',
  selesai: 'selesai'
};

export type StatusTahapan = (typeof StatusTahapan)[keyof typeof StatusTahapan]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type StatusTahapan = $Enums.StatusTahapan

export const StatusTahapan: typeof $Enums.StatusTahapan

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.accessToken`: Exposes CRUD operations for the **AccessToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessTokens
    * const accessTokens = await prisma.accessToken.findMany()
    * ```
    */
  get accessToken(): Prisma.AccessTokenDelegate<ExtArgs>;

  /**
   * `prisma.dinas`: Exposes CRUD operations for the **Dinas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dinas
    * const dinas = await prisma.dinas.findMany()
    * ```
    */
  get dinas(): Prisma.DinasDelegate<ExtArgs>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs>;

  /**
   * `prisma.dokumenProgram`: Exposes CRUD operations for the **DokumenProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DokumenPrograms
    * const dokumenPrograms = await prisma.dokumenProgram.findMany()
    * ```
    */
  get dokumenProgram(): Prisma.DokumenProgramDelegate<ExtArgs>;

  /**
   * `prisma.pengadaan`: Exposes CRUD operations for the **Pengadaan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pengadaans
    * const pengadaans = await prisma.pengadaan.findMany()
    * ```
    */
  get pengadaan(): Prisma.PengadaanDelegate<ExtArgs>;

  /**
   * `prisma.tahapan`: Exposes CRUD operations for the **Tahapan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tahapans
    * const tahapans = await prisma.tahapan.findMany()
    * ```
    */
  get tahapan(): Prisma.TahapanDelegate<ExtArgs>;

  /**
   * `prisma.transaksiPengadaan`: Exposes CRUD operations for the **TransaksiPengadaan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransaksiPengadaans
    * const transaksiPengadaans = await prisma.transaksiPengadaan.findMany()
    * ```
    */
  get transaksiPengadaan(): Prisma.TransaksiPengadaanDelegate<ExtArgs>;

  /**
   * `prisma.progresTahapan`: Exposes CRUD operations for the **ProgresTahapan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgresTahapans
    * const progresTahapans = await prisma.progresTahapan.findMany()
    * ```
    */
  get progresTahapan(): Prisma.ProgresTahapanDelegate<ExtArgs>;

  /**
   * `prisma.dokumenProgresTahapan`: Exposes CRUD operations for the **DokumenProgresTahapan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DokumenProgresTahapans
    * const dokumenProgresTahapans = await prisma.dokumenProgresTahapan.findMany()
    * ```
    */
  get dokumenProgresTahapan(): Prisma.DokumenProgresTahapanDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AccessToken: 'AccessToken',
    Dinas: 'Dinas',
    Program: 'Program',
    DokumenProgram: 'DokumenProgram',
    Pengadaan: 'Pengadaan',
    Tahapan: 'Tahapan',
    TransaksiPengadaan: 'TransaksiPengadaan',
    ProgresTahapan: 'ProgresTahapan',
    DokumenProgresTahapan: 'DokumenProgresTahapan'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "accessToken" | "dinas" | "program" | "dokumenProgram" | "pengadaan" | "tahapan" | "transaksiPengadaan" | "progresTahapan" | "dokumenProgresTahapan"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AccessToken: {
        payload: Prisma.$AccessTokenPayload<ExtArgs>
        fields: Prisma.AccessTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          findFirst: {
            args: Prisma.AccessTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          findMany: {
            args: Prisma.AccessTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>[]
          }
          create: {
            args: Prisma.AccessTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          createMany: {
            args: Prisma.AccessTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccessTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          update: {
            args: Prisma.AccessTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          deleteMany: {
            args: Prisma.AccessTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccessTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          aggregate: {
            args: Prisma.AccessTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessToken>
          }
          groupBy: {
            args: Prisma.AccessTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessTokenCountArgs<ExtArgs>
            result: $Utils.Optional<AccessTokenCountAggregateOutputType> | number
          }
        }
      }
      Dinas: {
        payload: Prisma.$DinasPayload<ExtArgs>
        fields: Prisma.DinasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DinasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DinasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload>
          }
          findFirst: {
            args: Prisma.DinasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DinasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload>
          }
          findMany: {
            args: Prisma.DinasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload>[]
          }
          create: {
            args: Prisma.DinasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload>
          }
          createMany: {
            args: Prisma.DinasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DinasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload>
          }
          update: {
            args: Prisma.DinasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload>
          }
          deleteMany: {
            args: Prisma.DinasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DinasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DinasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinasPayload>
          }
          aggregate: {
            args: Prisma.DinasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDinas>
          }
          groupBy: {
            args: Prisma.DinasGroupByArgs<ExtArgs>
            result: $Utils.Optional<DinasGroupByOutputType>[]
          }
          count: {
            args: Prisma.DinasCountArgs<ExtArgs>
            result: $Utils.Optional<DinasCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      DokumenProgram: {
        payload: Prisma.$DokumenProgramPayload<ExtArgs>
        fields: Prisma.DokumenProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DokumenProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DokumenProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload>
          }
          findFirst: {
            args: Prisma.DokumenProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DokumenProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload>
          }
          findMany: {
            args: Prisma.DokumenProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload>[]
          }
          create: {
            args: Prisma.DokumenProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload>
          }
          createMany: {
            args: Prisma.DokumenProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DokumenProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload>
          }
          update: {
            args: Prisma.DokumenProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload>
          }
          deleteMany: {
            args: Prisma.DokumenProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DokumenProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DokumenProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgramPayload>
          }
          aggregate: {
            args: Prisma.DokumenProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDokumenProgram>
          }
          groupBy: {
            args: Prisma.DokumenProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<DokumenProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.DokumenProgramCountArgs<ExtArgs>
            result: $Utils.Optional<DokumenProgramCountAggregateOutputType> | number
          }
        }
      }
      Pengadaan: {
        payload: Prisma.$PengadaanPayload<ExtArgs>
        fields: Prisma.PengadaanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PengadaanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PengadaanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload>
          }
          findFirst: {
            args: Prisma.PengadaanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PengadaanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload>
          }
          findMany: {
            args: Prisma.PengadaanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload>[]
          }
          create: {
            args: Prisma.PengadaanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload>
          }
          createMany: {
            args: Prisma.PengadaanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PengadaanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload>
          }
          update: {
            args: Prisma.PengadaanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload>
          }
          deleteMany: {
            args: Prisma.PengadaanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PengadaanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PengadaanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengadaanPayload>
          }
          aggregate: {
            args: Prisma.PengadaanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePengadaan>
          }
          groupBy: {
            args: Prisma.PengadaanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PengadaanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PengadaanCountArgs<ExtArgs>
            result: $Utils.Optional<PengadaanCountAggregateOutputType> | number
          }
        }
      }
      Tahapan: {
        payload: Prisma.$TahapanPayload<ExtArgs>
        fields: Prisma.TahapanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TahapanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TahapanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload>
          }
          findFirst: {
            args: Prisma.TahapanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TahapanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload>
          }
          findMany: {
            args: Prisma.TahapanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload>[]
          }
          create: {
            args: Prisma.TahapanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload>
          }
          createMany: {
            args: Prisma.TahapanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TahapanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload>
          }
          update: {
            args: Prisma.TahapanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload>
          }
          deleteMany: {
            args: Prisma.TahapanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TahapanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TahapanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahapanPayload>
          }
          aggregate: {
            args: Prisma.TahapanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTahapan>
          }
          groupBy: {
            args: Prisma.TahapanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TahapanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TahapanCountArgs<ExtArgs>
            result: $Utils.Optional<TahapanCountAggregateOutputType> | number
          }
        }
      }
      TransaksiPengadaan: {
        payload: Prisma.$TransaksiPengadaanPayload<ExtArgs>
        fields: Prisma.TransaksiPengadaanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransaksiPengadaanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransaksiPengadaanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload>
          }
          findFirst: {
            args: Prisma.TransaksiPengadaanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransaksiPengadaanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload>
          }
          findMany: {
            args: Prisma.TransaksiPengadaanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload>[]
          }
          create: {
            args: Prisma.TransaksiPengadaanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload>
          }
          createMany: {
            args: Prisma.TransaksiPengadaanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransaksiPengadaanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload>
          }
          update: {
            args: Prisma.TransaksiPengadaanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload>
          }
          deleteMany: {
            args: Prisma.TransaksiPengadaanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransaksiPengadaanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransaksiPengadaanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransaksiPengadaanPayload>
          }
          aggregate: {
            args: Prisma.TransaksiPengadaanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaksiPengadaan>
          }
          groupBy: {
            args: Prisma.TransaksiPengadaanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransaksiPengadaanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransaksiPengadaanCountArgs<ExtArgs>
            result: $Utils.Optional<TransaksiPengadaanCountAggregateOutputType> | number
          }
        }
      }
      ProgresTahapan: {
        payload: Prisma.$ProgresTahapanPayload<ExtArgs>
        fields: Prisma.ProgresTahapanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgresTahapanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgresTahapanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload>
          }
          findFirst: {
            args: Prisma.ProgresTahapanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgresTahapanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload>
          }
          findMany: {
            args: Prisma.ProgresTahapanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload>[]
          }
          create: {
            args: Prisma.ProgresTahapanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload>
          }
          createMany: {
            args: Prisma.ProgresTahapanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProgresTahapanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload>
          }
          update: {
            args: Prisma.ProgresTahapanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload>
          }
          deleteMany: {
            args: Prisma.ProgresTahapanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgresTahapanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgresTahapanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgresTahapanPayload>
          }
          aggregate: {
            args: Prisma.ProgresTahapanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgresTahapan>
          }
          groupBy: {
            args: Prisma.ProgresTahapanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgresTahapanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgresTahapanCountArgs<ExtArgs>
            result: $Utils.Optional<ProgresTahapanCountAggregateOutputType> | number
          }
        }
      }
      DokumenProgresTahapan: {
        payload: Prisma.$DokumenProgresTahapanPayload<ExtArgs>
        fields: Prisma.DokumenProgresTahapanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DokumenProgresTahapanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DokumenProgresTahapanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload>
          }
          findFirst: {
            args: Prisma.DokumenProgresTahapanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DokumenProgresTahapanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload>
          }
          findMany: {
            args: Prisma.DokumenProgresTahapanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload>[]
          }
          create: {
            args: Prisma.DokumenProgresTahapanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload>
          }
          createMany: {
            args: Prisma.DokumenProgresTahapanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DokumenProgresTahapanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload>
          }
          update: {
            args: Prisma.DokumenProgresTahapanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload>
          }
          deleteMany: {
            args: Prisma.DokumenProgresTahapanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DokumenProgresTahapanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DokumenProgresTahapanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DokumenProgresTahapanPayload>
          }
          aggregate: {
            args: Prisma.DokumenProgresTahapanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDokumenProgresTahapan>
          }
          groupBy: {
            args: Prisma.DokumenProgresTahapanGroupByArgs<ExtArgs>
            result: $Utils.Optional<DokumenProgresTahapanGroupByOutputType>[]
          }
          count: {
            args: Prisma.DokumenProgresTahapanCountArgs<ExtArgs>
            result: $Utils.Optional<DokumenProgresTahapanCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accessTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accessTokens?: boolean | UserCountOutputTypeCountAccessTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessTokenWhereInput
  }


  /**
   * Count Type DinasCountOutputType
   */

  export type DinasCountOutputType = {
    users: number
    programs: number
  }

  export type DinasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | DinasCountOutputTypeCountUsersArgs
    programs?: boolean | DinasCountOutputTypeCountProgramsArgs
  }

  // Custom InputTypes
  /**
   * DinasCountOutputType without action
   */
  export type DinasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinasCountOutputType
     */
    select?: DinasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DinasCountOutputType without action
   */
  export type DinasCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * DinasCountOutputType without action
   */
  export type DinasCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    pengadaan: number
    dokumen: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pengadaan?: boolean | ProgramCountOutputTypeCountPengadaanArgs
    dokumen?: boolean | ProgramCountOutputTypeCountDokumenArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountPengadaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransaksiPengadaanWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountDokumenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DokumenProgramWhereInput
  }


  /**
   * Count Type PengadaanCountOutputType
   */

  export type PengadaanCountOutputType = {
    tahapan: number
    transaksi: number
  }

  export type PengadaanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tahapan?: boolean | PengadaanCountOutputTypeCountTahapanArgs
    transaksi?: boolean | PengadaanCountOutputTypeCountTransaksiArgs
  }

  // Custom InputTypes
  /**
   * PengadaanCountOutputType without action
   */
  export type PengadaanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PengadaanCountOutputType
     */
    select?: PengadaanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PengadaanCountOutputType without action
   */
  export type PengadaanCountOutputTypeCountTahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TahapanWhereInput
  }

  /**
   * PengadaanCountOutputType without action
   */
  export type PengadaanCountOutputTypeCountTransaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransaksiPengadaanWhereInput
  }


  /**
   * Count Type TahapanCountOutputType
   */

  export type TahapanCountOutputType = {
    progresTahapan: number
  }

  export type TahapanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progresTahapan?: boolean | TahapanCountOutputTypeCountProgresTahapanArgs
  }

  // Custom InputTypes
  /**
   * TahapanCountOutputType without action
   */
  export type TahapanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahapanCountOutputType
     */
    select?: TahapanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TahapanCountOutputType without action
   */
  export type TahapanCountOutputTypeCountProgresTahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgresTahapanWhereInput
  }


  /**
   * Count Type TransaksiPengadaanCountOutputType
   */

  export type TransaksiPengadaanCountOutputType = {
    progresTahapan: number
  }

  export type TransaksiPengadaanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progresTahapan?: boolean | TransaksiPengadaanCountOutputTypeCountProgresTahapanArgs
  }

  // Custom InputTypes
  /**
   * TransaksiPengadaanCountOutputType without action
   */
  export type TransaksiPengadaanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaanCountOutputType
     */
    select?: TransaksiPengadaanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransaksiPengadaanCountOutputType without action
   */
  export type TransaksiPengadaanCountOutputTypeCountProgresTahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgresTahapanWhereInput
  }


  /**
   * Count Type ProgresTahapanCountOutputType
   */

  export type ProgresTahapanCountOutputType = {
    dokumen: number
  }

  export type ProgresTahapanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dokumen?: boolean | ProgresTahapanCountOutputTypeCountDokumenArgs
  }

  // Custom InputTypes
  /**
   * ProgresTahapanCountOutputType without action
   */
  export type ProgresTahapanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapanCountOutputType
     */
    select?: ProgresTahapanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgresTahapanCountOutputType without action
   */
  export type ProgresTahapanCountOutputTypeCountDokumenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DokumenProgresTahapanWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    dinasId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    dinasId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    dinasId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    dinasId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    name: number
    role: number
    dinasId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    dinasId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    dinasId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    dinasId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    dinasId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    role?: true
    dinasId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    name: string | null
    role: $Enums.Role
    dinasId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    dinasId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dinas?: boolean | User$dinasArgs<ExtArgs>
    accessTokens?: boolean | User$accessTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    dinasId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dinas?: boolean | User$dinasArgs<ExtArgs>
    accessTokens?: boolean | User$accessTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      dinas: Prisma.$DinasPayload<ExtArgs> | null
      accessTokens: Prisma.$AccessTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      name: string | null
      role: $Enums.Role
      dinasId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dinas<T extends User$dinasArgs<ExtArgs> = {}>(args?: Subset<T, User$dinasArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    accessTokens<T extends User$accessTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$accessTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly dinasId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.dinas
   */
  export type User$dinasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    where?: DinasWhereInput
  }

  /**
   * User.accessTokens
   */
  export type User$accessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    where?: AccessTokenWhereInput
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    cursor?: AccessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AccessToken
   */

  export type AggregateAccessToken = {
    _count: AccessTokenCountAggregateOutputType | null
    _avg: AccessTokenAvgAggregateOutputType | null
    _sum: AccessTokenSumAggregateOutputType | null
    _min: AccessTokenMinAggregateOutputType | null
    _max: AccessTokenMaxAggregateOutputType | null
  }

  export type AccessTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AccessTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AccessTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type AccessTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type AccessTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    revoked: number
    createdAt: number
    _all: number
  }


  export type AccessTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccessTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccessTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
  }

  export type AccessTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
  }

  export type AccessTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
    _all?: true
  }

  export type AccessTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessToken to aggregate.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessTokens
    **/
    _count?: true | AccessTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessTokenMaxAggregateInputType
  }

  export type GetAccessTokenAggregateType<T extends AccessTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessToken[P]>
      : GetScalarType<T[P], AggregateAccessToken[P]>
  }




  export type AccessTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessTokenWhereInput
    orderBy?: AccessTokenOrderByWithAggregationInput | AccessTokenOrderByWithAggregationInput[]
    by: AccessTokenScalarFieldEnum[] | AccessTokenScalarFieldEnum
    having?: AccessTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessTokenCountAggregateInputType | true
    _avg?: AccessTokenAvgAggregateInputType
    _sum?: AccessTokenSumAggregateInputType
    _min?: AccessTokenMinAggregateInputType
    _max?: AccessTokenMaxAggregateInputType
  }

  export type AccessTokenGroupByOutputType = {
    id: number
    token: string
    userId: number
    expiresAt: Date | null
    revoked: boolean
    createdAt: Date
    _count: AccessTokenCountAggregateOutputType | null
    _avg: AccessTokenAvgAggregateOutputType | null
    _sum: AccessTokenSumAggregateOutputType | null
    _min: AccessTokenMinAggregateOutputType | null
    _max: AccessTokenMaxAggregateOutputType | null
  }

  type GetAccessTokenGroupByPayload<T extends AccessTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessTokenGroupByOutputType[P]>
            : GetScalarType<T[P], AccessTokenGroupByOutputType[P]>
        }
      >
    >


  export type AccessTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessToken"]>


  export type AccessTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
  }

  export type AccessTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccessTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      userId: number
      expiresAt: Date | null
      revoked: boolean
      createdAt: Date
    }, ExtArgs["result"]["accessToken"]>
    composites: {}
  }

  type AccessTokenGetPayload<S extends boolean | null | undefined | AccessTokenDefaultArgs> = $Result.GetResult<Prisma.$AccessTokenPayload, S>

  type AccessTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccessTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccessTokenCountAggregateInputType | true
    }

  export interface AccessTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessToken'], meta: { name: 'AccessToken' } }
    /**
     * Find zero or one AccessToken that matches the filter.
     * @param {AccessTokenFindUniqueArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessTokenFindUniqueArgs>(args: SelectSubset<T, AccessTokenFindUniqueArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccessToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccessTokenFindUniqueOrThrowArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccessToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindFirstArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessTokenFindFirstArgs>(args?: SelectSubset<T, AccessTokenFindFirstArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccessToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindFirstOrThrowArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccessTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessTokens
     * const accessTokens = await prisma.accessToken.findMany()
     * 
     * // Get first 10 AccessTokens
     * const accessTokens = await prisma.accessToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessTokenWithIdOnly = await prisma.accessToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessTokenFindManyArgs>(args?: SelectSubset<T, AccessTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccessToken.
     * @param {AccessTokenCreateArgs} args - Arguments to create a AccessToken.
     * @example
     * // Create one AccessToken
     * const AccessToken = await prisma.accessToken.create({
     *   data: {
     *     // ... data to create a AccessToken
     *   }
     * })
     * 
     */
    create<T extends AccessTokenCreateArgs>(args: SelectSubset<T, AccessTokenCreateArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccessTokens.
     * @param {AccessTokenCreateManyArgs} args - Arguments to create many AccessTokens.
     * @example
     * // Create many AccessTokens
     * const accessToken = await prisma.accessToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessTokenCreateManyArgs>(args?: SelectSubset<T, AccessTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccessToken.
     * @param {AccessTokenDeleteArgs} args - Arguments to delete one AccessToken.
     * @example
     * // Delete one AccessToken
     * const AccessToken = await prisma.accessToken.delete({
     *   where: {
     *     // ... filter to delete one AccessToken
     *   }
     * })
     * 
     */
    delete<T extends AccessTokenDeleteArgs>(args: SelectSubset<T, AccessTokenDeleteArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccessToken.
     * @param {AccessTokenUpdateArgs} args - Arguments to update one AccessToken.
     * @example
     * // Update one AccessToken
     * const accessToken = await prisma.accessToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessTokenUpdateArgs>(args: SelectSubset<T, AccessTokenUpdateArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccessTokens.
     * @param {AccessTokenDeleteManyArgs} args - Arguments to filter AccessTokens to delete.
     * @example
     * // Delete a few AccessTokens
     * const { count } = await prisma.accessToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessTokenDeleteManyArgs>(args?: SelectSubset<T, AccessTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessTokens
     * const accessToken = await prisma.accessToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessTokenUpdateManyArgs>(args: SelectSubset<T, AccessTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccessToken.
     * @param {AccessTokenUpsertArgs} args - Arguments to update or create a AccessToken.
     * @example
     * // Update or create a AccessToken
     * const accessToken = await prisma.accessToken.upsert({
     *   create: {
     *     // ... data to create a AccessToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessToken we want to update
     *   }
     * })
     */
    upsert<T extends AccessTokenUpsertArgs>(args: SelectSubset<T, AccessTokenUpsertArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenCountArgs} args - Arguments to filter AccessTokens to count.
     * @example
     * // Count the number of AccessTokens
     * const count = await prisma.accessToken.count({
     *   where: {
     *     // ... the filter for the AccessTokens we want to count
     *   }
     * })
    **/
    count<T extends AccessTokenCountArgs>(
      args?: Subset<T, AccessTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessTokenAggregateArgs>(args: Subset<T, AccessTokenAggregateArgs>): Prisma.PrismaPromise<GetAccessTokenAggregateType<T>>

    /**
     * Group by AccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessTokenGroupByArgs['orderBy'] }
        : { orderBy?: AccessTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessToken model
   */
  readonly fields: AccessTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessToken model
   */ 
  interface AccessTokenFieldRefs {
    readonly id: FieldRef<"AccessToken", 'Int'>
    readonly token: FieldRef<"AccessToken", 'String'>
    readonly userId: FieldRef<"AccessToken", 'Int'>
    readonly expiresAt: FieldRef<"AccessToken", 'DateTime'>
    readonly revoked: FieldRef<"AccessToken", 'Boolean'>
    readonly createdAt: FieldRef<"AccessToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccessToken findUnique
   */
  export type AccessTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where: AccessTokenWhereUniqueInput
  }

  /**
   * AccessToken findUniqueOrThrow
   */
  export type AccessTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where: AccessTokenWhereUniqueInput
  }

  /**
   * AccessToken findFirst
   */
  export type AccessTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessTokens.
     */
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * AccessToken findFirstOrThrow
   */
  export type AccessTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessTokens.
     */
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * AccessToken findMany
   */
  export type AccessTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessTokens to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * AccessToken create
   */
  export type AccessTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessToken.
     */
    data: XOR<AccessTokenCreateInput, AccessTokenUncheckedCreateInput>
  }

  /**
   * AccessToken createMany
   */
  export type AccessTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessTokens.
     */
    data: AccessTokenCreateManyInput | AccessTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessToken update
   */
  export type AccessTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessToken.
     */
    data: XOR<AccessTokenUpdateInput, AccessTokenUncheckedUpdateInput>
    /**
     * Choose, which AccessToken to update.
     */
    where: AccessTokenWhereUniqueInput
  }

  /**
   * AccessToken updateMany
   */
  export type AccessTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessTokens.
     */
    data: XOR<AccessTokenUpdateManyMutationInput, AccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which AccessTokens to update
     */
    where?: AccessTokenWhereInput
  }

  /**
   * AccessToken upsert
   */
  export type AccessTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessToken to update in case it exists.
     */
    where: AccessTokenWhereUniqueInput
    /**
     * In case the AccessToken found by the `where` argument doesn't exist, create a new AccessToken with this data.
     */
    create: XOR<AccessTokenCreateInput, AccessTokenUncheckedCreateInput>
    /**
     * In case the AccessToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessTokenUpdateInput, AccessTokenUncheckedUpdateInput>
  }

  /**
   * AccessToken delete
   */
  export type AccessTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter which AccessToken to delete.
     */
    where: AccessTokenWhereUniqueInput
  }

  /**
   * AccessToken deleteMany
   */
  export type AccessTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessTokens to delete
     */
    where?: AccessTokenWhereInput
  }

  /**
   * AccessToken without action
   */
  export type AccessTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
  }


  /**
   * Model Dinas
   */

  export type AggregateDinas = {
    _count: DinasCountAggregateOutputType | null
    _avg: DinasAvgAggregateOutputType | null
    _sum: DinasSumAggregateOutputType | null
    _min: DinasMinAggregateOutputType | null
    _max: DinasMaxAggregateOutputType | null
  }

  export type DinasAvgAggregateOutputType = {
    id: number | null
  }

  export type DinasSumAggregateOutputType = {
    id: number | null
  }

  export type DinasMinAggregateOutputType = {
    id: number | null
    namaDinas: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DinasMaxAggregateOutputType = {
    id: number | null
    namaDinas: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DinasCountAggregateOutputType = {
    id: number
    namaDinas: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DinasAvgAggregateInputType = {
    id?: true
  }

  export type DinasSumAggregateInputType = {
    id?: true
  }

  export type DinasMinAggregateInputType = {
    id?: true
    namaDinas?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DinasMaxAggregateInputType = {
    id?: true
    namaDinas?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DinasCountAggregateInputType = {
    id?: true
    namaDinas?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DinasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dinas to aggregate.
     */
    where?: DinasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dinas to fetch.
     */
    orderBy?: DinasOrderByWithRelationInput | DinasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DinasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dinas
    **/
    _count?: true | DinasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DinasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DinasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DinasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DinasMaxAggregateInputType
  }

  export type GetDinasAggregateType<T extends DinasAggregateArgs> = {
        [P in keyof T & keyof AggregateDinas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDinas[P]>
      : GetScalarType<T[P], AggregateDinas[P]>
  }




  export type DinasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DinasWhereInput
    orderBy?: DinasOrderByWithAggregationInput | DinasOrderByWithAggregationInput[]
    by: DinasScalarFieldEnum[] | DinasScalarFieldEnum
    having?: DinasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DinasCountAggregateInputType | true
    _avg?: DinasAvgAggregateInputType
    _sum?: DinasSumAggregateInputType
    _min?: DinasMinAggregateInputType
    _max?: DinasMaxAggregateInputType
  }

  export type DinasGroupByOutputType = {
    id: number
    namaDinas: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: DinasCountAggregateOutputType | null
    _avg: DinasAvgAggregateOutputType | null
    _sum: DinasSumAggregateOutputType | null
    _min: DinasMinAggregateOutputType | null
    _max: DinasMaxAggregateOutputType | null
  }

  type GetDinasGroupByPayload<T extends DinasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DinasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DinasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DinasGroupByOutputType[P]>
            : GetScalarType<T[P], DinasGroupByOutputType[P]>
        }
      >
    >


  export type DinasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaDinas?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Dinas$usersArgs<ExtArgs>
    programs?: boolean | Dinas$programsArgs<ExtArgs>
    _count?: boolean | DinasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dinas"]>


  export type DinasSelectScalar = {
    id?: boolean
    namaDinas?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DinasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Dinas$usersArgs<ExtArgs>
    programs?: boolean | Dinas$programsArgs<ExtArgs>
    _count?: boolean | DinasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DinasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dinas"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      programs: Prisma.$ProgramPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      namaDinas: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dinas"]>
    composites: {}
  }

  type DinasGetPayload<S extends boolean | null | undefined | DinasDefaultArgs> = $Result.GetResult<Prisma.$DinasPayload, S>

  type DinasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DinasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DinasCountAggregateInputType | true
    }

  export interface DinasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dinas'], meta: { name: 'Dinas' } }
    /**
     * Find zero or one Dinas that matches the filter.
     * @param {DinasFindUniqueArgs} args - Arguments to find a Dinas
     * @example
     * // Get one Dinas
     * const dinas = await prisma.dinas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DinasFindUniqueArgs>(args: SelectSubset<T, DinasFindUniqueArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dinas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DinasFindUniqueOrThrowArgs} args - Arguments to find a Dinas
     * @example
     * // Get one Dinas
     * const dinas = await prisma.dinas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DinasFindUniqueOrThrowArgs>(args: SelectSubset<T, DinasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dinas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinasFindFirstArgs} args - Arguments to find a Dinas
     * @example
     * // Get one Dinas
     * const dinas = await prisma.dinas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DinasFindFirstArgs>(args?: SelectSubset<T, DinasFindFirstArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dinas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinasFindFirstOrThrowArgs} args - Arguments to find a Dinas
     * @example
     * // Get one Dinas
     * const dinas = await prisma.dinas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DinasFindFirstOrThrowArgs>(args?: SelectSubset<T, DinasFindFirstOrThrowArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dinas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dinas
     * const dinas = await prisma.dinas.findMany()
     * 
     * // Get first 10 Dinas
     * const dinas = await prisma.dinas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dinasWithIdOnly = await prisma.dinas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DinasFindManyArgs>(args?: SelectSubset<T, DinasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dinas.
     * @param {DinasCreateArgs} args - Arguments to create a Dinas.
     * @example
     * // Create one Dinas
     * const Dinas = await prisma.dinas.create({
     *   data: {
     *     // ... data to create a Dinas
     *   }
     * })
     * 
     */
    create<T extends DinasCreateArgs>(args: SelectSubset<T, DinasCreateArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dinas.
     * @param {DinasCreateManyArgs} args - Arguments to create many Dinas.
     * @example
     * // Create many Dinas
     * const dinas = await prisma.dinas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DinasCreateManyArgs>(args?: SelectSubset<T, DinasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dinas.
     * @param {DinasDeleteArgs} args - Arguments to delete one Dinas.
     * @example
     * // Delete one Dinas
     * const Dinas = await prisma.dinas.delete({
     *   where: {
     *     // ... filter to delete one Dinas
     *   }
     * })
     * 
     */
    delete<T extends DinasDeleteArgs>(args: SelectSubset<T, DinasDeleteArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dinas.
     * @param {DinasUpdateArgs} args - Arguments to update one Dinas.
     * @example
     * // Update one Dinas
     * const dinas = await prisma.dinas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DinasUpdateArgs>(args: SelectSubset<T, DinasUpdateArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dinas.
     * @param {DinasDeleteManyArgs} args - Arguments to filter Dinas to delete.
     * @example
     * // Delete a few Dinas
     * const { count } = await prisma.dinas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DinasDeleteManyArgs>(args?: SelectSubset<T, DinasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dinas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dinas
     * const dinas = await prisma.dinas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DinasUpdateManyArgs>(args: SelectSubset<T, DinasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dinas.
     * @param {DinasUpsertArgs} args - Arguments to update or create a Dinas.
     * @example
     * // Update or create a Dinas
     * const dinas = await prisma.dinas.upsert({
     *   create: {
     *     // ... data to create a Dinas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dinas we want to update
     *   }
     * })
     */
    upsert<T extends DinasUpsertArgs>(args: SelectSubset<T, DinasUpsertArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dinas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinasCountArgs} args - Arguments to filter Dinas to count.
     * @example
     * // Count the number of Dinas
     * const count = await prisma.dinas.count({
     *   where: {
     *     // ... the filter for the Dinas we want to count
     *   }
     * })
    **/
    count<T extends DinasCountArgs>(
      args?: Subset<T, DinasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DinasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dinas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DinasAggregateArgs>(args: Subset<T, DinasAggregateArgs>): Prisma.PrismaPromise<GetDinasAggregateType<T>>

    /**
     * Group by Dinas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DinasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DinasGroupByArgs['orderBy'] }
        : { orderBy?: DinasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DinasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDinasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dinas model
   */
  readonly fields: DinasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dinas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DinasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Dinas$usersArgs<ExtArgs> = {}>(args?: Subset<T, Dinas$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    programs<T extends Dinas$programsArgs<ExtArgs> = {}>(args?: Subset<T, Dinas$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dinas model
   */ 
  interface DinasFieldRefs {
    readonly id: FieldRef<"Dinas", 'Int'>
    readonly namaDinas: FieldRef<"Dinas", 'String'>
    readonly slug: FieldRef<"Dinas", 'String'>
    readonly createdAt: FieldRef<"Dinas", 'DateTime'>
    readonly updatedAt: FieldRef<"Dinas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dinas findUnique
   */
  export type DinasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * Filter, which Dinas to fetch.
     */
    where: DinasWhereUniqueInput
  }

  /**
   * Dinas findUniqueOrThrow
   */
  export type DinasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * Filter, which Dinas to fetch.
     */
    where: DinasWhereUniqueInput
  }

  /**
   * Dinas findFirst
   */
  export type DinasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * Filter, which Dinas to fetch.
     */
    where?: DinasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dinas to fetch.
     */
    orderBy?: DinasOrderByWithRelationInput | DinasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dinas.
     */
    cursor?: DinasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dinas.
     */
    distinct?: DinasScalarFieldEnum | DinasScalarFieldEnum[]
  }

  /**
   * Dinas findFirstOrThrow
   */
  export type DinasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * Filter, which Dinas to fetch.
     */
    where?: DinasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dinas to fetch.
     */
    orderBy?: DinasOrderByWithRelationInput | DinasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dinas.
     */
    cursor?: DinasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dinas.
     */
    distinct?: DinasScalarFieldEnum | DinasScalarFieldEnum[]
  }

  /**
   * Dinas findMany
   */
  export type DinasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * Filter, which Dinas to fetch.
     */
    where?: DinasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dinas to fetch.
     */
    orderBy?: DinasOrderByWithRelationInput | DinasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dinas.
     */
    cursor?: DinasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dinas.
     */
    skip?: number
    distinct?: DinasScalarFieldEnum | DinasScalarFieldEnum[]
  }

  /**
   * Dinas create
   */
  export type DinasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * The data needed to create a Dinas.
     */
    data: XOR<DinasCreateInput, DinasUncheckedCreateInput>
  }

  /**
   * Dinas createMany
   */
  export type DinasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dinas.
     */
    data: DinasCreateManyInput | DinasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dinas update
   */
  export type DinasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * The data needed to update a Dinas.
     */
    data: XOR<DinasUpdateInput, DinasUncheckedUpdateInput>
    /**
     * Choose, which Dinas to update.
     */
    where: DinasWhereUniqueInput
  }

  /**
   * Dinas updateMany
   */
  export type DinasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dinas.
     */
    data: XOR<DinasUpdateManyMutationInput, DinasUncheckedUpdateManyInput>
    /**
     * Filter which Dinas to update
     */
    where?: DinasWhereInput
  }

  /**
   * Dinas upsert
   */
  export type DinasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * The filter to search for the Dinas to update in case it exists.
     */
    where: DinasWhereUniqueInput
    /**
     * In case the Dinas found by the `where` argument doesn't exist, create a new Dinas with this data.
     */
    create: XOR<DinasCreateInput, DinasUncheckedCreateInput>
    /**
     * In case the Dinas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DinasUpdateInput, DinasUncheckedUpdateInput>
  }

  /**
   * Dinas delete
   */
  export type DinasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
    /**
     * Filter which Dinas to delete.
     */
    where: DinasWhereUniqueInput
  }

  /**
   * Dinas deleteMany
   */
  export type DinasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dinas to delete
     */
    where?: DinasWhereInput
  }

  /**
   * Dinas.users
   */
  export type Dinas$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Dinas.programs
   */
  export type Dinas$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Dinas without action
   */
  export type DinasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dinas
     */
    select?: DinasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinasInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    id: number | null
    anggaran: number | null
    dinasId: number | null
  }

  export type ProgramSumAggregateOutputType = {
    id: number | null
    anggaran: bigint | null
    dinasId: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: number | null
    namaProgram: string | null
    slug: string | null
    anggaran: bigint | null
    isPrioritas: boolean | null
    dinasId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: number | null
    namaProgram: string | null
    slug: string | null
    anggaran: bigint | null
    isPrioritas: boolean | null
    dinasId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    namaProgram: number
    slug: number
    anggaran: number
    isPrioritas: number
    dinasId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    id?: true
    anggaran?: true
    dinasId?: true
  }

  export type ProgramSumAggregateInputType = {
    id?: true
    anggaran?: true
    dinasId?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    namaProgram?: true
    slug?: true
    anggaran?: true
    isPrioritas?: true
    dinasId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    namaProgram?: true
    slug?: true
    anggaran?: true
    isPrioritas?: true
    dinasId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    namaProgram?: true
    slug?: true
    anggaran?: true
    isPrioritas?: true
    dinasId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: number
    namaProgram: string
    slug: string
    anggaran: bigint
    isPrioritas: boolean
    dinasId: number
    createdAt: Date
    updatedAt: Date
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaProgram?: boolean
    slug?: boolean
    anggaran?: boolean
    isPrioritas?: boolean
    dinasId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dinas?: boolean | DinasDefaultArgs<ExtArgs>
    pengadaan?: boolean | Program$pengadaanArgs<ExtArgs>
    dokumen?: boolean | Program$dokumenArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>


  export type ProgramSelectScalar = {
    id?: boolean
    namaProgram?: boolean
    slug?: boolean
    anggaran?: boolean
    isPrioritas?: boolean
    dinasId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dinas?: boolean | DinasDefaultArgs<ExtArgs>
    pengadaan?: boolean | Program$pengadaanArgs<ExtArgs>
    dokumen?: boolean | Program$dokumenArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      dinas: Prisma.$DinasPayload<ExtArgs>
      pengadaan: Prisma.$TransaksiPengadaanPayload<ExtArgs>[]
      dokumen: Prisma.$DokumenProgramPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      namaProgram: string
      slug: string
      anggaran: bigint
      isPrioritas: boolean
      dinasId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dinas<T extends DinasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DinasDefaultArgs<ExtArgs>>): Prisma__DinasClient<$Result.GetResult<Prisma.$DinasPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pengadaan<T extends Program$pengadaanArgs<ExtArgs> = {}>(args?: Subset<T, Program$pengadaanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "findMany"> | Null>
    dokumen<T extends Program$dokumenArgs<ExtArgs> = {}>(args?: Subset<T, Program$dokumenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */ 
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'Int'>
    readonly namaProgram: FieldRef<"Program", 'String'>
    readonly slug: FieldRef<"Program", 'String'>
    readonly anggaran: FieldRef<"Program", 'BigInt'>
    readonly isPrioritas: FieldRef<"Program", 'Boolean'>
    readonly dinasId: FieldRef<"Program", 'Int'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
  }

  /**
   * Program.pengadaan
   */
  export type Program$pengadaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    where?: TransaksiPengadaanWhereInput
    orderBy?: TransaksiPengadaanOrderByWithRelationInput | TransaksiPengadaanOrderByWithRelationInput[]
    cursor?: TransaksiPengadaanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransaksiPengadaanScalarFieldEnum | TransaksiPengadaanScalarFieldEnum[]
  }

  /**
   * Program.dokumen
   */
  export type Program$dokumenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    where?: DokumenProgramWhereInput
    orderBy?: DokumenProgramOrderByWithRelationInput | DokumenProgramOrderByWithRelationInput[]
    cursor?: DokumenProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DokumenProgramScalarFieldEnum | DokumenProgramScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model DokumenProgram
   */

  export type AggregateDokumenProgram = {
    _count: DokumenProgramCountAggregateOutputType | null
    _avg: DokumenProgramAvgAggregateOutputType | null
    _sum: DokumenProgramSumAggregateOutputType | null
    _min: DokumenProgramMinAggregateOutputType | null
    _max: DokumenProgramMaxAggregateOutputType | null
  }

  export type DokumenProgramAvgAggregateOutputType = {
    id: number | null
    programId: number | null
  }

  export type DokumenProgramSumAggregateOutputType = {
    id: number | null
    programId: number | null
  }

  export type DokumenProgramMinAggregateOutputType = {
    id: number | null
    programId: number | null
    namaFile: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type DokumenProgramMaxAggregateOutputType = {
    id: number | null
    programId: number | null
    namaFile: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type DokumenProgramCountAggregateOutputType = {
    id: number
    programId: number
    namaFile: number
    fileUrl: number
    createdAt: number
    _all: number
  }


  export type DokumenProgramAvgAggregateInputType = {
    id?: true
    programId?: true
  }

  export type DokumenProgramSumAggregateInputType = {
    id?: true
    programId?: true
  }

  export type DokumenProgramMinAggregateInputType = {
    id?: true
    programId?: true
    namaFile?: true
    fileUrl?: true
    createdAt?: true
  }

  export type DokumenProgramMaxAggregateInputType = {
    id?: true
    programId?: true
    namaFile?: true
    fileUrl?: true
    createdAt?: true
  }

  export type DokumenProgramCountAggregateInputType = {
    id?: true
    programId?: true
    namaFile?: true
    fileUrl?: true
    createdAt?: true
    _all?: true
  }

  export type DokumenProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DokumenProgram to aggregate.
     */
    where?: DokumenProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DokumenPrograms to fetch.
     */
    orderBy?: DokumenProgramOrderByWithRelationInput | DokumenProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DokumenProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DokumenPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DokumenPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DokumenPrograms
    **/
    _count?: true | DokumenProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DokumenProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DokumenProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DokumenProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DokumenProgramMaxAggregateInputType
  }

  export type GetDokumenProgramAggregateType<T extends DokumenProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateDokumenProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDokumenProgram[P]>
      : GetScalarType<T[P], AggregateDokumenProgram[P]>
  }




  export type DokumenProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DokumenProgramWhereInput
    orderBy?: DokumenProgramOrderByWithAggregationInput | DokumenProgramOrderByWithAggregationInput[]
    by: DokumenProgramScalarFieldEnum[] | DokumenProgramScalarFieldEnum
    having?: DokumenProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DokumenProgramCountAggregateInputType | true
    _avg?: DokumenProgramAvgAggregateInputType
    _sum?: DokumenProgramSumAggregateInputType
    _min?: DokumenProgramMinAggregateInputType
    _max?: DokumenProgramMaxAggregateInputType
  }

  export type DokumenProgramGroupByOutputType = {
    id: number
    programId: number
    namaFile: string
    fileUrl: string
    createdAt: Date
    _count: DokumenProgramCountAggregateOutputType | null
    _avg: DokumenProgramAvgAggregateOutputType | null
    _sum: DokumenProgramSumAggregateOutputType | null
    _min: DokumenProgramMinAggregateOutputType | null
    _max: DokumenProgramMaxAggregateOutputType | null
  }

  type GetDokumenProgramGroupByPayload<T extends DokumenProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DokumenProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DokumenProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DokumenProgramGroupByOutputType[P]>
            : GetScalarType<T[P], DokumenProgramGroupByOutputType[P]>
        }
      >
    >


  export type DokumenProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    namaFile?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dokumenProgram"]>


  export type DokumenProgramSelectScalar = {
    id?: boolean
    programId?: boolean
    namaFile?: boolean
    fileUrl?: boolean
    createdAt?: boolean
  }

  export type DokumenProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $DokumenProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DokumenProgram"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      programId: number
      namaFile: string
      fileUrl: string
      createdAt: Date
    }, ExtArgs["result"]["dokumenProgram"]>
    composites: {}
  }

  type DokumenProgramGetPayload<S extends boolean | null | undefined | DokumenProgramDefaultArgs> = $Result.GetResult<Prisma.$DokumenProgramPayload, S>

  type DokumenProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DokumenProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DokumenProgramCountAggregateInputType | true
    }

  export interface DokumenProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DokumenProgram'], meta: { name: 'DokumenProgram' } }
    /**
     * Find zero or one DokumenProgram that matches the filter.
     * @param {DokumenProgramFindUniqueArgs} args - Arguments to find a DokumenProgram
     * @example
     * // Get one DokumenProgram
     * const dokumenProgram = await prisma.dokumenProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DokumenProgramFindUniqueArgs>(args: SelectSubset<T, DokumenProgramFindUniqueArgs<ExtArgs>>): Prisma__DokumenProgramClient<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DokumenProgram that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DokumenProgramFindUniqueOrThrowArgs} args - Arguments to find a DokumenProgram
     * @example
     * // Get one DokumenProgram
     * const dokumenProgram = await prisma.dokumenProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DokumenProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, DokumenProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DokumenProgramClient<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DokumenProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgramFindFirstArgs} args - Arguments to find a DokumenProgram
     * @example
     * // Get one DokumenProgram
     * const dokumenProgram = await prisma.dokumenProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DokumenProgramFindFirstArgs>(args?: SelectSubset<T, DokumenProgramFindFirstArgs<ExtArgs>>): Prisma__DokumenProgramClient<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DokumenProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgramFindFirstOrThrowArgs} args - Arguments to find a DokumenProgram
     * @example
     * // Get one DokumenProgram
     * const dokumenProgram = await prisma.dokumenProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DokumenProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, DokumenProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__DokumenProgramClient<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DokumenPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DokumenPrograms
     * const dokumenPrograms = await prisma.dokumenProgram.findMany()
     * 
     * // Get first 10 DokumenPrograms
     * const dokumenPrograms = await prisma.dokumenProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dokumenProgramWithIdOnly = await prisma.dokumenProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DokumenProgramFindManyArgs>(args?: SelectSubset<T, DokumenProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DokumenProgram.
     * @param {DokumenProgramCreateArgs} args - Arguments to create a DokumenProgram.
     * @example
     * // Create one DokumenProgram
     * const DokumenProgram = await prisma.dokumenProgram.create({
     *   data: {
     *     // ... data to create a DokumenProgram
     *   }
     * })
     * 
     */
    create<T extends DokumenProgramCreateArgs>(args: SelectSubset<T, DokumenProgramCreateArgs<ExtArgs>>): Prisma__DokumenProgramClient<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DokumenPrograms.
     * @param {DokumenProgramCreateManyArgs} args - Arguments to create many DokumenPrograms.
     * @example
     * // Create many DokumenPrograms
     * const dokumenProgram = await prisma.dokumenProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DokumenProgramCreateManyArgs>(args?: SelectSubset<T, DokumenProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DokumenProgram.
     * @param {DokumenProgramDeleteArgs} args - Arguments to delete one DokumenProgram.
     * @example
     * // Delete one DokumenProgram
     * const DokumenProgram = await prisma.dokumenProgram.delete({
     *   where: {
     *     // ... filter to delete one DokumenProgram
     *   }
     * })
     * 
     */
    delete<T extends DokumenProgramDeleteArgs>(args: SelectSubset<T, DokumenProgramDeleteArgs<ExtArgs>>): Prisma__DokumenProgramClient<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DokumenProgram.
     * @param {DokumenProgramUpdateArgs} args - Arguments to update one DokumenProgram.
     * @example
     * // Update one DokumenProgram
     * const dokumenProgram = await prisma.dokumenProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DokumenProgramUpdateArgs>(args: SelectSubset<T, DokumenProgramUpdateArgs<ExtArgs>>): Prisma__DokumenProgramClient<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DokumenPrograms.
     * @param {DokumenProgramDeleteManyArgs} args - Arguments to filter DokumenPrograms to delete.
     * @example
     * // Delete a few DokumenPrograms
     * const { count } = await prisma.dokumenProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DokumenProgramDeleteManyArgs>(args?: SelectSubset<T, DokumenProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DokumenPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DokumenPrograms
     * const dokumenProgram = await prisma.dokumenProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DokumenProgramUpdateManyArgs>(args: SelectSubset<T, DokumenProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DokumenProgram.
     * @param {DokumenProgramUpsertArgs} args - Arguments to update or create a DokumenProgram.
     * @example
     * // Update or create a DokumenProgram
     * const dokumenProgram = await prisma.dokumenProgram.upsert({
     *   create: {
     *     // ... data to create a DokumenProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DokumenProgram we want to update
     *   }
     * })
     */
    upsert<T extends DokumenProgramUpsertArgs>(args: SelectSubset<T, DokumenProgramUpsertArgs<ExtArgs>>): Prisma__DokumenProgramClient<$Result.GetResult<Prisma.$DokumenProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DokumenPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgramCountArgs} args - Arguments to filter DokumenPrograms to count.
     * @example
     * // Count the number of DokumenPrograms
     * const count = await prisma.dokumenProgram.count({
     *   where: {
     *     // ... the filter for the DokumenPrograms we want to count
     *   }
     * })
    **/
    count<T extends DokumenProgramCountArgs>(
      args?: Subset<T, DokumenProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DokumenProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DokumenProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DokumenProgramAggregateArgs>(args: Subset<T, DokumenProgramAggregateArgs>): Prisma.PrismaPromise<GetDokumenProgramAggregateType<T>>

    /**
     * Group by DokumenProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DokumenProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DokumenProgramGroupByArgs['orderBy'] }
        : { orderBy?: DokumenProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DokumenProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDokumenProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DokumenProgram model
   */
  readonly fields: DokumenProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DokumenProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DokumenProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DokumenProgram model
   */ 
  interface DokumenProgramFieldRefs {
    readonly id: FieldRef<"DokumenProgram", 'Int'>
    readonly programId: FieldRef<"DokumenProgram", 'Int'>
    readonly namaFile: FieldRef<"DokumenProgram", 'String'>
    readonly fileUrl: FieldRef<"DokumenProgram", 'String'>
    readonly createdAt: FieldRef<"DokumenProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DokumenProgram findUnique
   */
  export type DokumenProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgram to fetch.
     */
    where: DokumenProgramWhereUniqueInput
  }

  /**
   * DokumenProgram findUniqueOrThrow
   */
  export type DokumenProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgram to fetch.
     */
    where: DokumenProgramWhereUniqueInput
  }

  /**
   * DokumenProgram findFirst
   */
  export type DokumenProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgram to fetch.
     */
    where?: DokumenProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DokumenPrograms to fetch.
     */
    orderBy?: DokumenProgramOrderByWithRelationInput | DokumenProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DokumenPrograms.
     */
    cursor?: DokumenProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DokumenPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DokumenPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DokumenPrograms.
     */
    distinct?: DokumenProgramScalarFieldEnum | DokumenProgramScalarFieldEnum[]
  }

  /**
   * DokumenProgram findFirstOrThrow
   */
  export type DokumenProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgram to fetch.
     */
    where?: DokumenProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DokumenPrograms to fetch.
     */
    orderBy?: DokumenProgramOrderByWithRelationInput | DokumenProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DokumenPrograms.
     */
    cursor?: DokumenProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DokumenPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DokumenPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DokumenPrograms.
     */
    distinct?: DokumenProgramScalarFieldEnum | DokumenProgramScalarFieldEnum[]
  }

  /**
   * DokumenProgram findMany
   */
  export type DokumenProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * Filter, which DokumenPrograms to fetch.
     */
    where?: DokumenProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DokumenPrograms to fetch.
     */
    orderBy?: DokumenProgramOrderByWithRelationInput | DokumenProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DokumenPrograms.
     */
    cursor?: DokumenProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DokumenPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DokumenPrograms.
     */
    skip?: number
    distinct?: DokumenProgramScalarFieldEnum | DokumenProgramScalarFieldEnum[]
  }

  /**
   * DokumenProgram create
   */
  export type DokumenProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a DokumenProgram.
     */
    data: XOR<DokumenProgramCreateInput, DokumenProgramUncheckedCreateInput>
  }

  /**
   * DokumenProgram createMany
   */
  export type DokumenProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DokumenPrograms.
     */
    data: DokumenProgramCreateManyInput | DokumenProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DokumenProgram update
   */
  export type DokumenProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a DokumenProgram.
     */
    data: XOR<DokumenProgramUpdateInput, DokumenProgramUncheckedUpdateInput>
    /**
     * Choose, which DokumenProgram to update.
     */
    where: DokumenProgramWhereUniqueInput
  }

  /**
   * DokumenProgram updateMany
   */
  export type DokumenProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DokumenPrograms.
     */
    data: XOR<DokumenProgramUpdateManyMutationInput, DokumenProgramUncheckedUpdateManyInput>
    /**
     * Filter which DokumenPrograms to update
     */
    where?: DokumenProgramWhereInput
  }

  /**
   * DokumenProgram upsert
   */
  export type DokumenProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the DokumenProgram to update in case it exists.
     */
    where: DokumenProgramWhereUniqueInput
    /**
     * In case the DokumenProgram found by the `where` argument doesn't exist, create a new DokumenProgram with this data.
     */
    create: XOR<DokumenProgramCreateInput, DokumenProgramUncheckedCreateInput>
    /**
     * In case the DokumenProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DokumenProgramUpdateInput, DokumenProgramUncheckedUpdateInput>
  }

  /**
   * DokumenProgram delete
   */
  export type DokumenProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
    /**
     * Filter which DokumenProgram to delete.
     */
    where: DokumenProgramWhereUniqueInput
  }

  /**
   * DokumenProgram deleteMany
   */
  export type DokumenProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DokumenPrograms to delete
     */
    where?: DokumenProgramWhereInput
  }

  /**
   * DokumenProgram without action
   */
  export type DokumenProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgram
     */
    select?: DokumenProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgramInclude<ExtArgs> | null
  }


  /**
   * Model Pengadaan
   */

  export type AggregatePengadaan = {
    _count: PengadaanCountAggregateOutputType | null
    _avg: PengadaanAvgAggregateOutputType | null
    _sum: PengadaanSumAggregateOutputType | null
    _min: PengadaanMinAggregateOutputType | null
    _max: PengadaanMaxAggregateOutputType | null
  }

  export type PengadaanAvgAggregateOutputType = {
    id: number | null
  }

  export type PengadaanSumAggregateOutputType = {
    id: number | null
  }

  export type PengadaanMinAggregateOutputType = {
    id: number | null
    namaPengadaan: string | null
  }

  export type PengadaanMaxAggregateOutputType = {
    id: number | null
    namaPengadaan: string | null
  }

  export type PengadaanCountAggregateOutputType = {
    id: number
    namaPengadaan: number
    _all: number
  }


  export type PengadaanAvgAggregateInputType = {
    id?: true
  }

  export type PengadaanSumAggregateInputType = {
    id?: true
  }

  export type PengadaanMinAggregateInputType = {
    id?: true
    namaPengadaan?: true
  }

  export type PengadaanMaxAggregateInputType = {
    id?: true
    namaPengadaan?: true
  }

  export type PengadaanCountAggregateInputType = {
    id?: true
    namaPengadaan?: true
    _all?: true
  }

  export type PengadaanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengadaan to aggregate.
     */
    where?: PengadaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengadaans to fetch.
     */
    orderBy?: PengadaanOrderByWithRelationInput | PengadaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PengadaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengadaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengadaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pengadaans
    **/
    _count?: true | PengadaanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PengadaanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PengadaanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PengadaanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PengadaanMaxAggregateInputType
  }

  export type GetPengadaanAggregateType<T extends PengadaanAggregateArgs> = {
        [P in keyof T & keyof AggregatePengadaan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengadaan[P]>
      : GetScalarType<T[P], AggregatePengadaan[P]>
  }




  export type PengadaanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PengadaanWhereInput
    orderBy?: PengadaanOrderByWithAggregationInput | PengadaanOrderByWithAggregationInput[]
    by: PengadaanScalarFieldEnum[] | PengadaanScalarFieldEnum
    having?: PengadaanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PengadaanCountAggregateInputType | true
    _avg?: PengadaanAvgAggregateInputType
    _sum?: PengadaanSumAggregateInputType
    _min?: PengadaanMinAggregateInputType
    _max?: PengadaanMaxAggregateInputType
  }

  export type PengadaanGroupByOutputType = {
    id: number
    namaPengadaan: string
    _count: PengadaanCountAggregateOutputType | null
    _avg: PengadaanAvgAggregateOutputType | null
    _sum: PengadaanSumAggregateOutputType | null
    _min: PengadaanMinAggregateOutputType | null
    _max: PengadaanMaxAggregateOutputType | null
  }

  type GetPengadaanGroupByPayload<T extends PengadaanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PengadaanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PengadaanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PengadaanGroupByOutputType[P]>
            : GetScalarType<T[P], PengadaanGroupByOutputType[P]>
        }
      >
    >


  export type PengadaanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaPengadaan?: boolean
    tahapan?: boolean | Pengadaan$tahapanArgs<ExtArgs>
    transaksi?: boolean | Pengadaan$transaksiArgs<ExtArgs>
    _count?: boolean | PengadaanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengadaan"]>


  export type PengadaanSelectScalar = {
    id?: boolean
    namaPengadaan?: boolean
  }

  export type PengadaanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tahapan?: boolean | Pengadaan$tahapanArgs<ExtArgs>
    transaksi?: boolean | Pengadaan$transaksiArgs<ExtArgs>
    _count?: boolean | PengadaanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PengadaanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pengadaan"
    objects: {
      tahapan: Prisma.$TahapanPayload<ExtArgs>[]
      transaksi: Prisma.$TransaksiPengadaanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      namaPengadaan: string
    }, ExtArgs["result"]["pengadaan"]>
    composites: {}
  }

  type PengadaanGetPayload<S extends boolean | null | undefined | PengadaanDefaultArgs> = $Result.GetResult<Prisma.$PengadaanPayload, S>

  type PengadaanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PengadaanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PengadaanCountAggregateInputType | true
    }

  export interface PengadaanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pengadaan'], meta: { name: 'Pengadaan' } }
    /**
     * Find zero or one Pengadaan that matches the filter.
     * @param {PengadaanFindUniqueArgs} args - Arguments to find a Pengadaan
     * @example
     * // Get one Pengadaan
     * const pengadaan = await prisma.pengadaan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PengadaanFindUniqueArgs>(args: SelectSubset<T, PengadaanFindUniqueArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pengadaan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PengadaanFindUniqueOrThrowArgs} args - Arguments to find a Pengadaan
     * @example
     * // Get one Pengadaan
     * const pengadaan = await prisma.pengadaan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PengadaanFindUniqueOrThrowArgs>(args: SelectSubset<T, PengadaanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pengadaan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengadaanFindFirstArgs} args - Arguments to find a Pengadaan
     * @example
     * // Get one Pengadaan
     * const pengadaan = await prisma.pengadaan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PengadaanFindFirstArgs>(args?: SelectSubset<T, PengadaanFindFirstArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pengadaan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengadaanFindFirstOrThrowArgs} args - Arguments to find a Pengadaan
     * @example
     * // Get one Pengadaan
     * const pengadaan = await prisma.pengadaan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PengadaanFindFirstOrThrowArgs>(args?: SelectSubset<T, PengadaanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pengadaans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengadaanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pengadaans
     * const pengadaans = await prisma.pengadaan.findMany()
     * 
     * // Get first 10 Pengadaans
     * const pengadaans = await prisma.pengadaan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pengadaanWithIdOnly = await prisma.pengadaan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PengadaanFindManyArgs>(args?: SelectSubset<T, PengadaanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pengadaan.
     * @param {PengadaanCreateArgs} args - Arguments to create a Pengadaan.
     * @example
     * // Create one Pengadaan
     * const Pengadaan = await prisma.pengadaan.create({
     *   data: {
     *     // ... data to create a Pengadaan
     *   }
     * })
     * 
     */
    create<T extends PengadaanCreateArgs>(args: SelectSubset<T, PengadaanCreateArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pengadaans.
     * @param {PengadaanCreateManyArgs} args - Arguments to create many Pengadaans.
     * @example
     * // Create many Pengadaans
     * const pengadaan = await prisma.pengadaan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PengadaanCreateManyArgs>(args?: SelectSubset<T, PengadaanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pengadaan.
     * @param {PengadaanDeleteArgs} args - Arguments to delete one Pengadaan.
     * @example
     * // Delete one Pengadaan
     * const Pengadaan = await prisma.pengadaan.delete({
     *   where: {
     *     // ... filter to delete one Pengadaan
     *   }
     * })
     * 
     */
    delete<T extends PengadaanDeleteArgs>(args: SelectSubset<T, PengadaanDeleteArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pengadaan.
     * @param {PengadaanUpdateArgs} args - Arguments to update one Pengadaan.
     * @example
     * // Update one Pengadaan
     * const pengadaan = await prisma.pengadaan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PengadaanUpdateArgs>(args: SelectSubset<T, PengadaanUpdateArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pengadaans.
     * @param {PengadaanDeleteManyArgs} args - Arguments to filter Pengadaans to delete.
     * @example
     * // Delete a few Pengadaans
     * const { count } = await prisma.pengadaan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PengadaanDeleteManyArgs>(args?: SelectSubset<T, PengadaanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pengadaans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengadaanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pengadaans
     * const pengadaan = await prisma.pengadaan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PengadaanUpdateManyArgs>(args: SelectSubset<T, PengadaanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pengadaan.
     * @param {PengadaanUpsertArgs} args - Arguments to update or create a Pengadaan.
     * @example
     * // Update or create a Pengadaan
     * const pengadaan = await prisma.pengadaan.upsert({
     *   create: {
     *     // ... data to create a Pengadaan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengadaan we want to update
     *   }
     * })
     */
    upsert<T extends PengadaanUpsertArgs>(args: SelectSubset<T, PengadaanUpsertArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pengadaans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengadaanCountArgs} args - Arguments to filter Pengadaans to count.
     * @example
     * // Count the number of Pengadaans
     * const count = await prisma.pengadaan.count({
     *   where: {
     *     // ... the filter for the Pengadaans we want to count
     *   }
     * })
    **/
    count<T extends PengadaanCountArgs>(
      args?: Subset<T, PengadaanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PengadaanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengadaan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengadaanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PengadaanAggregateArgs>(args: Subset<T, PengadaanAggregateArgs>): Prisma.PrismaPromise<GetPengadaanAggregateType<T>>

    /**
     * Group by Pengadaan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengadaanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PengadaanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PengadaanGroupByArgs['orderBy'] }
        : { orderBy?: PengadaanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PengadaanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPengadaanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pengadaan model
   */
  readonly fields: PengadaanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pengadaan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PengadaanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tahapan<T extends Pengadaan$tahapanArgs<ExtArgs> = {}>(args?: Subset<T, Pengadaan$tahapanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "findMany"> | Null>
    transaksi<T extends Pengadaan$transaksiArgs<ExtArgs> = {}>(args?: Subset<T, Pengadaan$transaksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pengadaan model
   */ 
  interface PengadaanFieldRefs {
    readonly id: FieldRef<"Pengadaan", 'Int'>
    readonly namaPengadaan: FieldRef<"Pengadaan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pengadaan findUnique
   */
  export type PengadaanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * Filter, which Pengadaan to fetch.
     */
    where: PengadaanWhereUniqueInput
  }

  /**
   * Pengadaan findUniqueOrThrow
   */
  export type PengadaanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * Filter, which Pengadaan to fetch.
     */
    where: PengadaanWhereUniqueInput
  }

  /**
   * Pengadaan findFirst
   */
  export type PengadaanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * Filter, which Pengadaan to fetch.
     */
    where?: PengadaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengadaans to fetch.
     */
    orderBy?: PengadaanOrderByWithRelationInput | PengadaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pengadaans.
     */
    cursor?: PengadaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengadaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengadaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pengadaans.
     */
    distinct?: PengadaanScalarFieldEnum | PengadaanScalarFieldEnum[]
  }

  /**
   * Pengadaan findFirstOrThrow
   */
  export type PengadaanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * Filter, which Pengadaan to fetch.
     */
    where?: PengadaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengadaans to fetch.
     */
    orderBy?: PengadaanOrderByWithRelationInput | PengadaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pengadaans.
     */
    cursor?: PengadaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengadaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengadaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pengadaans.
     */
    distinct?: PengadaanScalarFieldEnum | PengadaanScalarFieldEnum[]
  }

  /**
   * Pengadaan findMany
   */
  export type PengadaanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * Filter, which Pengadaans to fetch.
     */
    where?: PengadaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengadaans to fetch.
     */
    orderBy?: PengadaanOrderByWithRelationInput | PengadaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pengadaans.
     */
    cursor?: PengadaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengadaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengadaans.
     */
    skip?: number
    distinct?: PengadaanScalarFieldEnum | PengadaanScalarFieldEnum[]
  }

  /**
   * Pengadaan create
   */
  export type PengadaanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * The data needed to create a Pengadaan.
     */
    data: XOR<PengadaanCreateInput, PengadaanUncheckedCreateInput>
  }

  /**
   * Pengadaan createMany
   */
  export type PengadaanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pengadaans.
     */
    data: PengadaanCreateManyInput | PengadaanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pengadaan update
   */
  export type PengadaanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * The data needed to update a Pengadaan.
     */
    data: XOR<PengadaanUpdateInput, PengadaanUncheckedUpdateInput>
    /**
     * Choose, which Pengadaan to update.
     */
    where: PengadaanWhereUniqueInput
  }

  /**
   * Pengadaan updateMany
   */
  export type PengadaanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pengadaans.
     */
    data: XOR<PengadaanUpdateManyMutationInput, PengadaanUncheckedUpdateManyInput>
    /**
     * Filter which Pengadaans to update
     */
    where?: PengadaanWhereInput
  }

  /**
   * Pengadaan upsert
   */
  export type PengadaanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * The filter to search for the Pengadaan to update in case it exists.
     */
    where: PengadaanWhereUniqueInput
    /**
     * In case the Pengadaan found by the `where` argument doesn't exist, create a new Pengadaan with this data.
     */
    create: XOR<PengadaanCreateInput, PengadaanUncheckedCreateInput>
    /**
     * In case the Pengadaan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PengadaanUpdateInput, PengadaanUncheckedUpdateInput>
  }

  /**
   * Pengadaan delete
   */
  export type PengadaanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
    /**
     * Filter which Pengadaan to delete.
     */
    where: PengadaanWhereUniqueInput
  }

  /**
   * Pengadaan deleteMany
   */
  export type PengadaanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengadaans to delete
     */
    where?: PengadaanWhereInput
  }

  /**
   * Pengadaan.tahapan
   */
  export type Pengadaan$tahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    where?: TahapanWhereInput
    orderBy?: TahapanOrderByWithRelationInput | TahapanOrderByWithRelationInput[]
    cursor?: TahapanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TahapanScalarFieldEnum | TahapanScalarFieldEnum[]
  }

  /**
   * Pengadaan.transaksi
   */
  export type Pengadaan$transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    where?: TransaksiPengadaanWhereInput
    orderBy?: TransaksiPengadaanOrderByWithRelationInput | TransaksiPengadaanOrderByWithRelationInput[]
    cursor?: TransaksiPengadaanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransaksiPengadaanScalarFieldEnum | TransaksiPengadaanScalarFieldEnum[]
  }

  /**
   * Pengadaan without action
   */
  export type PengadaanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengadaan
     */
    select?: PengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengadaanInclude<ExtArgs> | null
  }


  /**
   * Model Tahapan
   */

  export type AggregateTahapan = {
    _count: TahapanCountAggregateOutputType | null
    _avg: TahapanAvgAggregateOutputType | null
    _sum: TahapanSumAggregateOutputType | null
    _min: TahapanMinAggregateOutputType | null
    _max: TahapanMaxAggregateOutputType | null
  }

  export type TahapanAvgAggregateOutputType = {
    id: number | null
    pengadaanId: number | null
    noUrut: number | null
    standarWaktuHari: number | null
    bobot: number | null
  }

  export type TahapanSumAggregateOutputType = {
    id: number | null
    pengadaanId: number | null
    noUrut: number | null
    standarWaktuHari: number | null
    bobot: number | null
  }

  export type TahapanMinAggregateOutputType = {
    id: number | null
    pengadaanId: number | null
    noUrut: number | null
    namaTahapan: string | null
    standarWaktuHari: number | null
    isWaktuEditable: boolean | null
    bobot: number | null
  }

  export type TahapanMaxAggregateOutputType = {
    id: number | null
    pengadaanId: number | null
    noUrut: number | null
    namaTahapan: string | null
    standarWaktuHari: number | null
    isWaktuEditable: boolean | null
    bobot: number | null
  }

  export type TahapanCountAggregateOutputType = {
    id: number
    pengadaanId: number
    noUrut: number
    namaTahapan: number
    standarWaktuHari: number
    isWaktuEditable: number
    bobot: number
    _all: number
  }


  export type TahapanAvgAggregateInputType = {
    id?: true
    pengadaanId?: true
    noUrut?: true
    standarWaktuHari?: true
    bobot?: true
  }

  export type TahapanSumAggregateInputType = {
    id?: true
    pengadaanId?: true
    noUrut?: true
    standarWaktuHari?: true
    bobot?: true
  }

  export type TahapanMinAggregateInputType = {
    id?: true
    pengadaanId?: true
    noUrut?: true
    namaTahapan?: true
    standarWaktuHari?: true
    isWaktuEditable?: true
    bobot?: true
  }

  export type TahapanMaxAggregateInputType = {
    id?: true
    pengadaanId?: true
    noUrut?: true
    namaTahapan?: true
    standarWaktuHari?: true
    isWaktuEditable?: true
    bobot?: true
  }

  export type TahapanCountAggregateInputType = {
    id?: true
    pengadaanId?: true
    noUrut?: true
    namaTahapan?: true
    standarWaktuHari?: true
    isWaktuEditable?: true
    bobot?: true
    _all?: true
  }

  export type TahapanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tahapan to aggregate.
     */
    where?: TahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tahapans to fetch.
     */
    orderBy?: TahapanOrderByWithRelationInput | TahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tahapans
    **/
    _count?: true | TahapanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TahapanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TahapanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TahapanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TahapanMaxAggregateInputType
  }

  export type GetTahapanAggregateType<T extends TahapanAggregateArgs> = {
        [P in keyof T & keyof AggregateTahapan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTahapan[P]>
      : GetScalarType<T[P], AggregateTahapan[P]>
  }




  export type TahapanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TahapanWhereInput
    orderBy?: TahapanOrderByWithAggregationInput | TahapanOrderByWithAggregationInput[]
    by: TahapanScalarFieldEnum[] | TahapanScalarFieldEnum
    having?: TahapanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TahapanCountAggregateInputType | true
    _avg?: TahapanAvgAggregateInputType
    _sum?: TahapanSumAggregateInputType
    _min?: TahapanMinAggregateInputType
    _max?: TahapanMaxAggregateInputType
  }

  export type TahapanGroupByOutputType = {
    id: number
    pengadaanId: number
    noUrut: number
    namaTahapan: string
    standarWaktuHari: number | null
    isWaktuEditable: boolean
    bobot: number
    _count: TahapanCountAggregateOutputType | null
    _avg: TahapanAvgAggregateOutputType | null
    _sum: TahapanSumAggregateOutputType | null
    _min: TahapanMinAggregateOutputType | null
    _max: TahapanMaxAggregateOutputType | null
  }

  type GetTahapanGroupByPayload<T extends TahapanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TahapanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TahapanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TahapanGroupByOutputType[P]>
            : GetScalarType<T[P], TahapanGroupByOutputType[P]>
        }
      >
    >


  export type TahapanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pengadaanId?: boolean
    noUrut?: boolean
    namaTahapan?: boolean
    standarWaktuHari?: boolean
    isWaktuEditable?: boolean
    bobot?: boolean
    pengadaan?: boolean | PengadaanDefaultArgs<ExtArgs>
    progresTahapan?: boolean | Tahapan$progresTahapanArgs<ExtArgs>
    _count?: boolean | TahapanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tahapan"]>


  export type TahapanSelectScalar = {
    id?: boolean
    pengadaanId?: boolean
    noUrut?: boolean
    namaTahapan?: boolean
    standarWaktuHari?: boolean
    isWaktuEditable?: boolean
    bobot?: boolean
  }

  export type TahapanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pengadaan?: boolean | PengadaanDefaultArgs<ExtArgs>
    progresTahapan?: boolean | Tahapan$progresTahapanArgs<ExtArgs>
    _count?: boolean | TahapanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TahapanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tahapan"
    objects: {
      pengadaan: Prisma.$PengadaanPayload<ExtArgs>
      progresTahapan: Prisma.$ProgresTahapanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pengadaanId: number
      noUrut: number
      namaTahapan: string
      standarWaktuHari: number | null
      isWaktuEditable: boolean
      bobot: number
    }, ExtArgs["result"]["tahapan"]>
    composites: {}
  }

  type TahapanGetPayload<S extends boolean | null | undefined | TahapanDefaultArgs> = $Result.GetResult<Prisma.$TahapanPayload, S>

  type TahapanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TahapanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TahapanCountAggregateInputType | true
    }

  export interface TahapanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tahapan'], meta: { name: 'Tahapan' } }
    /**
     * Find zero or one Tahapan that matches the filter.
     * @param {TahapanFindUniqueArgs} args - Arguments to find a Tahapan
     * @example
     * // Get one Tahapan
     * const tahapan = await prisma.tahapan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TahapanFindUniqueArgs>(args: SelectSubset<T, TahapanFindUniqueArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tahapan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TahapanFindUniqueOrThrowArgs} args - Arguments to find a Tahapan
     * @example
     * // Get one Tahapan
     * const tahapan = await prisma.tahapan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TahapanFindUniqueOrThrowArgs>(args: SelectSubset<T, TahapanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tahapan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahapanFindFirstArgs} args - Arguments to find a Tahapan
     * @example
     * // Get one Tahapan
     * const tahapan = await prisma.tahapan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TahapanFindFirstArgs>(args?: SelectSubset<T, TahapanFindFirstArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tahapan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahapanFindFirstOrThrowArgs} args - Arguments to find a Tahapan
     * @example
     * // Get one Tahapan
     * const tahapan = await prisma.tahapan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TahapanFindFirstOrThrowArgs>(args?: SelectSubset<T, TahapanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tahapans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahapanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tahapans
     * const tahapans = await prisma.tahapan.findMany()
     * 
     * // Get first 10 Tahapans
     * const tahapans = await prisma.tahapan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tahapanWithIdOnly = await prisma.tahapan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TahapanFindManyArgs>(args?: SelectSubset<T, TahapanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tahapan.
     * @param {TahapanCreateArgs} args - Arguments to create a Tahapan.
     * @example
     * // Create one Tahapan
     * const Tahapan = await prisma.tahapan.create({
     *   data: {
     *     // ... data to create a Tahapan
     *   }
     * })
     * 
     */
    create<T extends TahapanCreateArgs>(args: SelectSubset<T, TahapanCreateArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tahapans.
     * @param {TahapanCreateManyArgs} args - Arguments to create many Tahapans.
     * @example
     * // Create many Tahapans
     * const tahapan = await prisma.tahapan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TahapanCreateManyArgs>(args?: SelectSubset<T, TahapanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tahapan.
     * @param {TahapanDeleteArgs} args - Arguments to delete one Tahapan.
     * @example
     * // Delete one Tahapan
     * const Tahapan = await prisma.tahapan.delete({
     *   where: {
     *     // ... filter to delete one Tahapan
     *   }
     * })
     * 
     */
    delete<T extends TahapanDeleteArgs>(args: SelectSubset<T, TahapanDeleteArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tahapan.
     * @param {TahapanUpdateArgs} args - Arguments to update one Tahapan.
     * @example
     * // Update one Tahapan
     * const tahapan = await prisma.tahapan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TahapanUpdateArgs>(args: SelectSubset<T, TahapanUpdateArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tahapans.
     * @param {TahapanDeleteManyArgs} args - Arguments to filter Tahapans to delete.
     * @example
     * // Delete a few Tahapans
     * const { count } = await prisma.tahapan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TahapanDeleteManyArgs>(args?: SelectSubset<T, TahapanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tahapans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahapanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tahapans
     * const tahapan = await prisma.tahapan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TahapanUpdateManyArgs>(args: SelectSubset<T, TahapanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tahapan.
     * @param {TahapanUpsertArgs} args - Arguments to update or create a Tahapan.
     * @example
     * // Update or create a Tahapan
     * const tahapan = await prisma.tahapan.upsert({
     *   create: {
     *     // ... data to create a Tahapan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tahapan we want to update
     *   }
     * })
     */
    upsert<T extends TahapanUpsertArgs>(args: SelectSubset<T, TahapanUpsertArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tahapans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahapanCountArgs} args - Arguments to filter Tahapans to count.
     * @example
     * // Count the number of Tahapans
     * const count = await prisma.tahapan.count({
     *   where: {
     *     // ... the filter for the Tahapans we want to count
     *   }
     * })
    **/
    count<T extends TahapanCountArgs>(
      args?: Subset<T, TahapanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TahapanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tahapan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahapanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TahapanAggregateArgs>(args: Subset<T, TahapanAggregateArgs>): Prisma.PrismaPromise<GetTahapanAggregateType<T>>

    /**
     * Group by Tahapan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahapanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TahapanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TahapanGroupByArgs['orderBy'] }
        : { orderBy?: TahapanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TahapanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTahapanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tahapan model
   */
  readonly fields: TahapanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tahapan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TahapanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pengadaan<T extends PengadaanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PengadaanDefaultArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progresTahapan<T extends Tahapan$progresTahapanArgs<ExtArgs> = {}>(args?: Subset<T, Tahapan$progresTahapanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tahapan model
   */ 
  interface TahapanFieldRefs {
    readonly id: FieldRef<"Tahapan", 'Int'>
    readonly pengadaanId: FieldRef<"Tahapan", 'Int'>
    readonly noUrut: FieldRef<"Tahapan", 'Int'>
    readonly namaTahapan: FieldRef<"Tahapan", 'String'>
    readonly standarWaktuHari: FieldRef<"Tahapan", 'Int'>
    readonly isWaktuEditable: FieldRef<"Tahapan", 'Boolean'>
    readonly bobot: FieldRef<"Tahapan", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tahapan findUnique
   */
  export type TahapanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * Filter, which Tahapan to fetch.
     */
    where: TahapanWhereUniqueInput
  }

  /**
   * Tahapan findUniqueOrThrow
   */
  export type TahapanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * Filter, which Tahapan to fetch.
     */
    where: TahapanWhereUniqueInput
  }

  /**
   * Tahapan findFirst
   */
  export type TahapanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * Filter, which Tahapan to fetch.
     */
    where?: TahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tahapans to fetch.
     */
    orderBy?: TahapanOrderByWithRelationInput | TahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tahapans.
     */
    cursor?: TahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tahapans.
     */
    distinct?: TahapanScalarFieldEnum | TahapanScalarFieldEnum[]
  }

  /**
   * Tahapan findFirstOrThrow
   */
  export type TahapanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * Filter, which Tahapan to fetch.
     */
    where?: TahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tahapans to fetch.
     */
    orderBy?: TahapanOrderByWithRelationInput | TahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tahapans.
     */
    cursor?: TahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tahapans.
     */
    distinct?: TahapanScalarFieldEnum | TahapanScalarFieldEnum[]
  }

  /**
   * Tahapan findMany
   */
  export type TahapanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * Filter, which Tahapans to fetch.
     */
    where?: TahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tahapans to fetch.
     */
    orderBy?: TahapanOrderByWithRelationInput | TahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tahapans.
     */
    cursor?: TahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tahapans.
     */
    skip?: number
    distinct?: TahapanScalarFieldEnum | TahapanScalarFieldEnum[]
  }

  /**
   * Tahapan create
   */
  export type TahapanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * The data needed to create a Tahapan.
     */
    data: XOR<TahapanCreateInput, TahapanUncheckedCreateInput>
  }

  /**
   * Tahapan createMany
   */
  export type TahapanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tahapans.
     */
    data: TahapanCreateManyInput | TahapanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tahapan update
   */
  export type TahapanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * The data needed to update a Tahapan.
     */
    data: XOR<TahapanUpdateInput, TahapanUncheckedUpdateInput>
    /**
     * Choose, which Tahapan to update.
     */
    where: TahapanWhereUniqueInput
  }

  /**
   * Tahapan updateMany
   */
  export type TahapanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tahapans.
     */
    data: XOR<TahapanUpdateManyMutationInput, TahapanUncheckedUpdateManyInput>
    /**
     * Filter which Tahapans to update
     */
    where?: TahapanWhereInput
  }

  /**
   * Tahapan upsert
   */
  export type TahapanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * The filter to search for the Tahapan to update in case it exists.
     */
    where: TahapanWhereUniqueInput
    /**
     * In case the Tahapan found by the `where` argument doesn't exist, create a new Tahapan with this data.
     */
    create: XOR<TahapanCreateInput, TahapanUncheckedCreateInput>
    /**
     * In case the Tahapan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TahapanUpdateInput, TahapanUncheckedUpdateInput>
  }

  /**
   * Tahapan delete
   */
  export type TahapanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
    /**
     * Filter which Tahapan to delete.
     */
    where: TahapanWhereUniqueInput
  }

  /**
   * Tahapan deleteMany
   */
  export type TahapanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tahapans to delete
     */
    where?: TahapanWhereInput
  }

  /**
   * Tahapan.progresTahapan
   */
  export type Tahapan$progresTahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    where?: ProgresTahapanWhereInput
    orderBy?: ProgresTahapanOrderByWithRelationInput | ProgresTahapanOrderByWithRelationInput[]
    cursor?: ProgresTahapanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgresTahapanScalarFieldEnum | ProgresTahapanScalarFieldEnum[]
  }

  /**
   * Tahapan without action
   */
  export type TahapanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahapan
     */
    select?: TahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahapanInclude<ExtArgs> | null
  }


  /**
   * Model TransaksiPengadaan
   */

  export type AggregateTransaksiPengadaan = {
    _count: TransaksiPengadaanCountAggregateOutputType | null
    _avg: TransaksiPengadaanAvgAggregateOutputType | null
    _sum: TransaksiPengadaanSumAggregateOutputType | null
    _min: TransaksiPengadaanMinAggregateOutputType | null
    _max: TransaksiPengadaanMaxAggregateOutputType | null
  }

  export type TransaksiPengadaanAvgAggregateOutputType = {
    id: number | null
    programId: number | null
    pengadaanId: number | null
  }

  export type TransaksiPengadaanSumAggregateOutputType = {
    id: number | null
    programId: number | null
    pengadaanId: number | null
  }

  export type TransaksiPengadaanMinAggregateOutputType = {
    id: number | null
    namaTransaksi: string | null
    title: string | null
    programId: number | null
    pengadaanId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransaksiPengadaanMaxAggregateOutputType = {
    id: number | null
    namaTransaksi: string | null
    title: string | null
    programId: number | null
    pengadaanId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransaksiPengadaanCountAggregateOutputType = {
    id: number
    namaTransaksi: number
    title: number
    programId: number
    pengadaanId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransaksiPengadaanAvgAggregateInputType = {
    id?: true
    programId?: true
    pengadaanId?: true
  }

  export type TransaksiPengadaanSumAggregateInputType = {
    id?: true
    programId?: true
    pengadaanId?: true
  }

  export type TransaksiPengadaanMinAggregateInputType = {
    id?: true
    namaTransaksi?: true
    title?: true
    programId?: true
    pengadaanId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransaksiPengadaanMaxAggregateInputType = {
    id?: true
    namaTransaksi?: true
    title?: true
    programId?: true
    pengadaanId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransaksiPengadaanCountAggregateInputType = {
    id?: true
    namaTransaksi?: true
    title?: true
    programId?: true
    pengadaanId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransaksiPengadaanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransaksiPengadaan to aggregate.
     */
    where?: TransaksiPengadaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransaksiPengadaans to fetch.
     */
    orderBy?: TransaksiPengadaanOrderByWithRelationInput | TransaksiPengadaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransaksiPengadaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransaksiPengadaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransaksiPengadaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransaksiPengadaans
    **/
    _count?: true | TransaksiPengadaanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransaksiPengadaanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransaksiPengadaanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransaksiPengadaanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransaksiPengadaanMaxAggregateInputType
  }

  export type GetTransaksiPengadaanAggregateType<T extends TransaksiPengadaanAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaksiPengadaan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaksiPengadaan[P]>
      : GetScalarType<T[P], AggregateTransaksiPengadaan[P]>
  }




  export type TransaksiPengadaanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransaksiPengadaanWhereInput
    orderBy?: TransaksiPengadaanOrderByWithAggregationInput | TransaksiPengadaanOrderByWithAggregationInput[]
    by: TransaksiPengadaanScalarFieldEnum[] | TransaksiPengadaanScalarFieldEnum
    having?: TransaksiPengadaanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransaksiPengadaanCountAggregateInputType | true
    _avg?: TransaksiPengadaanAvgAggregateInputType
    _sum?: TransaksiPengadaanSumAggregateInputType
    _min?: TransaksiPengadaanMinAggregateInputType
    _max?: TransaksiPengadaanMaxAggregateInputType
  }

  export type TransaksiPengadaanGroupByOutputType = {
    id: number
    namaTransaksi: string
    title: string
    programId: number
    pengadaanId: number
    createdAt: Date
    updatedAt: Date
    _count: TransaksiPengadaanCountAggregateOutputType | null
    _avg: TransaksiPengadaanAvgAggregateOutputType | null
    _sum: TransaksiPengadaanSumAggregateOutputType | null
    _min: TransaksiPengadaanMinAggregateOutputType | null
    _max: TransaksiPengadaanMaxAggregateOutputType | null
  }

  type GetTransaksiPengadaanGroupByPayload<T extends TransaksiPengadaanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransaksiPengadaanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransaksiPengadaanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransaksiPengadaanGroupByOutputType[P]>
            : GetScalarType<T[P], TransaksiPengadaanGroupByOutputType[P]>
        }
      >
    >


  export type TransaksiPengadaanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaTransaksi?: boolean
    title?: boolean
    programId?: boolean
    pengadaanId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    pengadaan?: boolean | PengadaanDefaultArgs<ExtArgs>
    progresTahapan?: boolean | TransaksiPengadaan$progresTahapanArgs<ExtArgs>
    _count?: boolean | TransaksiPengadaanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaksiPengadaan"]>


  export type TransaksiPengadaanSelectScalar = {
    id?: boolean
    namaTransaksi?: boolean
    title?: boolean
    programId?: boolean
    pengadaanId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransaksiPengadaanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    pengadaan?: boolean | PengadaanDefaultArgs<ExtArgs>
    progresTahapan?: boolean | TransaksiPengadaan$progresTahapanArgs<ExtArgs>
    _count?: boolean | TransaksiPengadaanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TransaksiPengadaanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransaksiPengadaan"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      pengadaan: Prisma.$PengadaanPayload<ExtArgs>
      progresTahapan: Prisma.$ProgresTahapanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      namaTransaksi: string
      title: string
      programId: number
      pengadaanId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaksiPengadaan"]>
    composites: {}
  }

  type TransaksiPengadaanGetPayload<S extends boolean | null | undefined | TransaksiPengadaanDefaultArgs> = $Result.GetResult<Prisma.$TransaksiPengadaanPayload, S>

  type TransaksiPengadaanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransaksiPengadaanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransaksiPengadaanCountAggregateInputType | true
    }

  export interface TransaksiPengadaanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransaksiPengadaan'], meta: { name: 'TransaksiPengadaan' } }
    /**
     * Find zero or one TransaksiPengadaan that matches the filter.
     * @param {TransaksiPengadaanFindUniqueArgs} args - Arguments to find a TransaksiPengadaan
     * @example
     * // Get one TransaksiPengadaan
     * const transaksiPengadaan = await prisma.transaksiPengadaan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransaksiPengadaanFindUniqueArgs>(args: SelectSubset<T, TransaksiPengadaanFindUniqueArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransaksiPengadaan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransaksiPengadaanFindUniqueOrThrowArgs} args - Arguments to find a TransaksiPengadaan
     * @example
     * // Get one TransaksiPengadaan
     * const transaksiPengadaan = await prisma.transaksiPengadaan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransaksiPengadaanFindUniqueOrThrowArgs>(args: SelectSubset<T, TransaksiPengadaanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransaksiPengadaan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiPengadaanFindFirstArgs} args - Arguments to find a TransaksiPengadaan
     * @example
     * // Get one TransaksiPengadaan
     * const transaksiPengadaan = await prisma.transaksiPengadaan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransaksiPengadaanFindFirstArgs>(args?: SelectSubset<T, TransaksiPengadaanFindFirstArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransaksiPengadaan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiPengadaanFindFirstOrThrowArgs} args - Arguments to find a TransaksiPengadaan
     * @example
     * // Get one TransaksiPengadaan
     * const transaksiPengadaan = await prisma.transaksiPengadaan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransaksiPengadaanFindFirstOrThrowArgs>(args?: SelectSubset<T, TransaksiPengadaanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransaksiPengadaans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiPengadaanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransaksiPengadaans
     * const transaksiPengadaans = await prisma.transaksiPengadaan.findMany()
     * 
     * // Get first 10 TransaksiPengadaans
     * const transaksiPengadaans = await prisma.transaksiPengadaan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaksiPengadaanWithIdOnly = await prisma.transaksiPengadaan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransaksiPengadaanFindManyArgs>(args?: SelectSubset<T, TransaksiPengadaanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransaksiPengadaan.
     * @param {TransaksiPengadaanCreateArgs} args - Arguments to create a TransaksiPengadaan.
     * @example
     * // Create one TransaksiPengadaan
     * const TransaksiPengadaan = await prisma.transaksiPengadaan.create({
     *   data: {
     *     // ... data to create a TransaksiPengadaan
     *   }
     * })
     * 
     */
    create<T extends TransaksiPengadaanCreateArgs>(args: SelectSubset<T, TransaksiPengadaanCreateArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransaksiPengadaans.
     * @param {TransaksiPengadaanCreateManyArgs} args - Arguments to create many TransaksiPengadaans.
     * @example
     * // Create many TransaksiPengadaans
     * const transaksiPengadaan = await prisma.transaksiPengadaan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransaksiPengadaanCreateManyArgs>(args?: SelectSubset<T, TransaksiPengadaanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransaksiPengadaan.
     * @param {TransaksiPengadaanDeleteArgs} args - Arguments to delete one TransaksiPengadaan.
     * @example
     * // Delete one TransaksiPengadaan
     * const TransaksiPengadaan = await prisma.transaksiPengadaan.delete({
     *   where: {
     *     // ... filter to delete one TransaksiPengadaan
     *   }
     * })
     * 
     */
    delete<T extends TransaksiPengadaanDeleteArgs>(args: SelectSubset<T, TransaksiPengadaanDeleteArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransaksiPengadaan.
     * @param {TransaksiPengadaanUpdateArgs} args - Arguments to update one TransaksiPengadaan.
     * @example
     * // Update one TransaksiPengadaan
     * const transaksiPengadaan = await prisma.transaksiPengadaan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransaksiPengadaanUpdateArgs>(args: SelectSubset<T, TransaksiPengadaanUpdateArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransaksiPengadaans.
     * @param {TransaksiPengadaanDeleteManyArgs} args - Arguments to filter TransaksiPengadaans to delete.
     * @example
     * // Delete a few TransaksiPengadaans
     * const { count } = await prisma.transaksiPengadaan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransaksiPengadaanDeleteManyArgs>(args?: SelectSubset<T, TransaksiPengadaanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransaksiPengadaans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiPengadaanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransaksiPengadaans
     * const transaksiPengadaan = await prisma.transaksiPengadaan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransaksiPengadaanUpdateManyArgs>(args: SelectSubset<T, TransaksiPengadaanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransaksiPengadaan.
     * @param {TransaksiPengadaanUpsertArgs} args - Arguments to update or create a TransaksiPengadaan.
     * @example
     * // Update or create a TransaksiPengadaan
     * const transaksiPengadaan = await prisma.transaksiPengadaan.upsert({
     *   create: {
     *     // ... data to create a TransaksiPengadaan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransaksiPengadaan we want to update
     *   }
     * })
     */
    upsert<T extends TransaksiPengadaanUpsertArgs>(args: SelectSubset<T, TransaksiPengadaanUpsertArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransaksiPengadaans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiPengadaanCountArgs} args - Arguments to filter TransaksiPengadaans to count.
     * @example
     * // Count the number of TransaksiPengadaans
     * const count = await prisma.transaksiPengadaan.count({
     *   where: {
     *     // ... the filter for the TransaksiPengadaans we want to count
     *   }
     * })
    **/
    count<T extends TransaksiPengadaanCountArgs>(
      args?: Subset<T, TransaksiPengadaanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransaksiPengadaanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransaksiPengadaan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiPengadaanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransaksiPengadaanAggregateArgs>(args: Subset<T, TransaksiPengadaanAggregateArgs>): Prisma.PrismaPromise<GetTransaksiPengadaanAggregateType<T>>

    /**
     * Group by TransaksiPengadaan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiPengadaanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransaksiPengadaanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransaksiPengadaanGroupByArgs['orderBy'] }
        : { orderBy?: TransaksiPengadaanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransaksiPengadaanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaksiPengadaanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransaksiPengadaan model
   */
  readonly fields: TransaksiPengadaanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransaksiPengadaan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransaksiPengadaanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pengadaan<T extends PengadaanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PengadaanDefaultArgs<ExtArgs>>): Prisma__PengadaanClient<$Result.GetResult<Prisma.$PengadaanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progresTahapan<T extends TransaksiPengadaan$progresTahapanArgs<ExtArgs> = {}>(args?: Subset<T, TransaksiPengadaan$progresTahapanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransaksiPengadaan model
   */ 
  interface TransaksiPengadaanFieldRefs {
    readonly id: FieldRef<"TransaksiPengadaan", 'Int'>
    readonly namaTransaksi: FieldRef<"TransaksiPengadaan", 'String'>
    readonly title: FieldRef<"TransaksiPengadaan", 'String'>
    readonly programId: FieldRef<"TransaksiPengadaan", 'Int'>
    readonly pengadaanId: FieldRef<"TransaksiPengadaan", 'Int'>
    readonly createdAt: FieldRef<"TransaksiPengadaan", 'DateTime'>
    readonly updatedAt: FieldRef<"TransaksiPengadaan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransaksiPengadaan findUnique
   */
  export type TransaksiPengadaanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * Filter, which TransaksiPengadaan to fetch.
     */
    where: TransaksiPengadaanWhereUniqueInput
  }

  /**
   * TransaksiPengadaan findUniqueOrThrow
   */
  export type TransaksiPengadaanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * Filter, which TransaksiPengadaan to fetch.
     */
    where: TransaksiPengadaanWhereUniqueInput
  }

  /**
   * TransaksiPengadaan findFirst
   */
  export type TransaksiPengadaanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * Filter, which TransaksiPengadaan to fetch.
     */
    where?: TransaksiPengadaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransaksiPengadaans to fetch.
     */
    orderBy?: TransaksiPengadaanOrderByWithRelationInput | TransaksiPengadaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransaksiPengadaans.
     */
    cursor?: TransaksiPengadaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransaksiPengadaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransaksiPengadaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransaksiPengadaans.
     */
    distinct?: TransaksiPengadaanScalarFieldEnum | TransaksiPengadaanScalarFieldEnum[]
  }

  /**
   * TransaksiPengadaan findFirstOrThrow
   */
  export type TransaksiPengadaanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * Filter, which TransaksiPengadaan to fetch.
     */
    where?: TransaksiPengadaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransaksiPengadaans to fetch.
     */
    orderBy?: TransaksiPengadaanOrderByWithRelationInput | TransaksiPengadaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransaksiPengadaans.
     */
    cursor?: TransaksiPengadaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransaksiPengadaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransaksiPengadaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransaksiPengadaans.
     */
    distinct?: TransaksiPengadaanScalarFieldEnum | TransaksiPengadaanScalarFieldEnum[]
  }

  /**
   * TransaksiPengadaan findMany
   */
  export type TransaksiPengadaanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * Filter, which TransaksiPengadaans to fetch.
     */
    where?: TransaksiPengadaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransaksiPengadaans to fetch.
     */
    orderBy?: TransaksiPengadaanOrderByWithRelationInput | TransaksiPengadaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransaksiPengadaans.
     */
    cursor?: TransaksiPengadaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransaksiPengadaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransaksiPengadaans.
     */
    skip?: number
    distinct?: TransaksiPengadaanScalarFieldEnum | TransaksiPengadaanScalarFieldEnum[]
  }

  /**
   * TransaksiPengadaan create
   */
  export type TransaksiPengadaanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * The data needed to create a TransaksiPengadaan.
     */
    data: XOR<TransaksiPengadaanCreateInput, TransaksiPengadaanUncheckedCreateInput>
  }

  /**
   * TransaksiPengadaan createMany
   */
  export type TransaksiPengadaanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransaksiPengadaans.
     */
    data: TransaksiPengadaanCreateManyInput | TransaksiPengadaanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransaksiPengadaan update
   */
  export type TransaksiPengadaanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * The data needed to update a TransaksiPengadaan.
     */
    data: XOR<TransaksiPengadaanUpdateInput, TransaksiPengadaanUncheckedUpdateInput>
    /**
     * Choose, which TransaksiPengadaan to update.
     */
    where: TransaksiPengadaanWhereUniqueInput
  }

  /**
   * TransaksiPengadaan updateMany
   */
  export type TransaksiPengadaanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransaksiPengadaans.
     */
    data: XOR<TransaksiPengadaanUpdateManyMutationInput, TransaksiPengadaanUncheckedUpdateManyInput>
    /**
     * Filter which TransaksiPengadaans to update
     */
    where?: TransaksiPengadaanWhereInput
  }

  /**
   * TransaksiPengadaan upsert
   */
  export type TransaksiPengadaanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * The filter to search for the TransaksiPengadaan to update in case it exists.
     */
    where: TransaksiPengadaanWhereUniqueInput
    /**
     * In case the TransaksiPengadaan found by the `where` argument doesn't exist, create a new TransaksiPengadaan with this data.
     */
    create: XOR<TransaksiPengadaanCreateInput, TransaksiPengadaanUncheckedCreateInput>
    /**
     * In case the TransaksiPengadaan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransaksiPengadaanUpdateInput, TransaksiPengadaanUncheckedUpdateInput>
  }

  /**
   * TransaksiPengadaan delete
   */
  export type TransaksiPengadaanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
    /**
     * Filter which TransaksiPengadaan to delete.
     */
    where: TransaksiPengadaanWhereUniqueInput
  }

  /**
   * TransaksiPengadaan deleteMany
   */
  export type TransaksiPengadaanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransaksiPengadaans to delete
     */
    where?: TransaksiPengadaanWhereInput
  }

  /**
   * TransaksiPengadaan.progresTahapan
   */
  export type TransaksiPengadaan$progresTahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    where?: ProgresTahapanWhereInput
    orderBy?: ProgresTahapanOrderByWithRelationInput | ProgresTahapanOrderByWithRelationInput[]
    cursor?: ProgresTahapanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgresTahapanScalarFieldEnum | ProgresTahapanScalarFieldEnum[]
  }

  /**
   * TransaksiPengadaan without action
   */
  export type TransaksiPengadaanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiPengadaan
     */
    select?: TransaksiPengadaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransaksiPengadaanInclude<ExtArgs> | null
  }


  /**
   * Model ProgresTahapan
   */

  export type AggregateProgresTahapan = {
    _count: ProgresTahapanCountAggregateOutputType | null
    _avg: ProgresTahapanAvgAggregateOutputType | null
    _sum: ProgresTahapanSumAggregateOutputType | null
    _min: ProgresTahapanMinAggregateOutputType | null
    _max: ProgresTahapanMaxAggregateOutputType | null
  }

  export type ProgresTahapanAvgAggregateOutputType = {
    id: number | null
    transaksiId: number | null
    tahapanId: number | null
  }

  export type ProgresTahapanSumAggregateOutputType = {
    id: number | null
    transaksiId: number | null
    tahapanId: number | null
  }

  export type ProgresTahapanMinAggregateOutputType = {
    id: number | null
    transaksiId: number | null
    tahapanId: number | null
    status: $Enums.StatusTahapan | null
    planningTanggalMulai: Date | null
    planningTanggalSelesai: Date | null
    aktualTanggalMulai: Date | null
    aktualTanggalSelesai: Date | null
    keterangan: string | null
    updatedAt: Date | null
  }

  export type ProgresTahapanMaxAggregateOutputType = {
    id: number | null
    transaksiId: number | null
    tahapanId: number | null
    status: $Enums.StatusTahapan | null
    planningTanggalMulai: Date | null
    planningTanggalSelesai: Date | null
    aktualTanggalMulai: Date | null
    aktualTanggalSelesai: Date | null
    keterangan: string | null
    updatedAt: Date | null
  }

  export type ProgresTahapanCountAggregateOutputType = {
    id: number
    transaksiId: number
    tahapanId: number
    status: number
    planningTanggalMulai: number
    planningTanggalSelesai: number
    aktualTanggalMulai: number
    aktualTanggalSelesai: number
    keterangan: number
    updatedAt: number
    _all: number
  }


  export type ProgresTahapanAvgAggregateInputType = {
    id?: true
    transaksiId?: true
    tahapanId?: true
  }

  export type ProgresTahapanSumAggregateInputType = {
    id?: true
    transaksiId?: true
    tahapanId?: true
  }

  export type ProgresTahapanMinAggregateInputType = {
    id?: true
    transaksiId?: true
    tahapanId?: true
    status?: true
    planningTanggalMulai?: true
    planningTanggalSelesai?: true
    aktualTanggalMulai?: true
    aktualTanggalSelesai?: true
    keterangan?: true
    updatedAt?: true
  }

  export type ProgresTahapanMaxAggregateInputType = {
    id?: true
    transaksiId?: true
    tahapanId?: true
    status?: true
    planningTanggalMulai?: true
    planningTanggalSelesai?: true
    aktualTanggalMulai?: true
    aktualTanggalSelesai?: true
    keterangan?: true
    updatedAt?: true
  }

  export type ProgresTahapanCountAggregateInputType = {
    id?: true
    transaksiId?: true
    tahapanId?: true
    status?: true
    planningTanggalMulai?: true
    planningTanggalSelesai?: true
    aktualTanggalMulai?: true
    aktualTanggalSelesai?: true
    keterangan?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgresTahapanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgresTahapan to aggregate.
     */
    where?: ProgresTahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgresTahapans to fetch.
     */
    orderBy?: ProgresTahapanOrderByWithRelationInput | ProgresTahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgresTahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgresTahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgresTahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgresTahapans
    **/
    _count?: true | ProgresTahapanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgresTahapanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgresTahapanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgresTahapanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgresTahapanMaxAggregateInputType
  }

  export type GetProgresTahapanAggregateType<T extends ProgresTahapanAggregateArgs> = {
        [P in keyof T & keyof AggregateProgresTahapan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgresTahapan[P]>
      : GetScalarType<T[P], AggregateProgresTahapan[P]>
  }




  export type ProgresTahapanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgresTahapanWhereInput
    orderBy?: ProgresTahapanOrderByWithAggregationInput | ProgresTahapanOrderByWithAggregationInput[]
    by: ProgresTahapanScalarFieldEnum[] | ProgresTahapanScalarFieldEnum
    having?: ProgresTahapanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgresTahapanCountAggregateInputType | true
    _avg?: ProgresTahapanAvgAggregateInputType
    _sum?: ProgresTahapanSumAggregateInputType
    _min?: ProgresTahapanMinAggregateInputType
    _max?: ProgresTahapanMaxAggregateInputType
  }

  export type ProgresTahapanGroupByOutputType = {
    id: number
    transaksiId: number
    tahapanId: number
    status: $Enums.StatusTahapan
    planningTanggalMulai: Date | null
    planningTanggalSelesai: Date | null
    aktualTanggalMulai: Date | null
    aktualTanggalSelesai: Date | null
    keterangan: string | null
    updatedAt: Date
    _count: ProgresTahapanCountAggregateOutputType | null
    _avg: ProgresTahapanAvgAggregateOutputType | null
    _sum: ProgresTahapanSumAggregateOutputType | null
    _min: ProgresTahapanMinAggregateOutputType | null
    _max: ProgresTahapanMaxAggregateOutputType | null
  }

  type GetProgresTahapanGroupByPayload<T extends ProgresTahapanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgresTahapanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgresTahapanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgresTahapanGroupByOutputType[P]>
            : GetScalarType<T[P], ProgresTahapanGroupByOutputType[P]>
        }
      >
    >


  export type ProgresTahapanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transaksiId?: boolean
    tahapanId?: boolean
    status?: boolean
    planningTanggalMulai?: boolean
    planningTanggalSelesai?: boolean
    aktualTanggalMulai?: boolean
    aktualTanggalSelesai?: boolean
    keterangan?: boolean
    updatedAt?: boolean
    transaksi?: boolean | TransaksiPengadaanDefaultArgs<ExtArgs>
    tahapan?: boolean | TahapanDefaultArgs<ExtArgs>
    dokumen?: boolean | ProgresTahapan$dokumenArgs<ExtArgs>
    _count?: boolean | ProgresTahapanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progresTahapan"]>


  export type ProgresTahapanSelectScalar = {
    id?: boolean
    transaksiId?: boolean
    tahapanId?: boolean
    status?: boolean
    planningTanggalMulai?: boolean
    planningTanggalSelesai?: boolean
    aktualTanggalMulai?: boolean
    aktualTanggalSelesai?: boolean
    keterangan?: boolean
    updatedAt?: boolean
  }

  export type ProgresTahapanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaksi?: boolean | TransaksiPengadaanDefaultArgs<ExtArgs>
    tahapan?: boolean | TahapanDefaultArgs<ExtArgs>
    dokumen?: boolean | ProgresTahapan$dokumenArgs<ExtArgs>
    _count?: boolean | ProgresTahapanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProgresTahapanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgresTahapan"
    objects: {
      transaksi: Prisma.$TransaksiPengadaanPayload<ExtArgs>
      tahapan: Prisma.$TahapanPayload<ExtArgs>
      dokumen: Prisma.$DokumenProgresTahapanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transaksiId: number
      tahapanId: number
      status: $Enums.StatusTahapan
      planningTanggalMulai: Date | null
      planningTanggalSelesai: Date | null
      aktualTanggalMulai: Date | null
      aktualTanggalSelesai: Date | null
      keterangan: string | null
      updatedAt: Date
    }, ExtArgs["result"]["progresTahapan"]>
    composites: {}
  }

  type ProgresTahapanGetPayload<S extends boolean | null | undefined | ProgresTahapanDefaultArgs> = $Result.GetResult<Prisma.$ProgresTahapanPayload, S>

  type ProgresTahapanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgresTahapanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgresTahapanCountAggregateInputType | true
    }

  export interface ProgresTahapanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgresTahapan'], meta: { name: 'ProgresTahapan' } }
    /**
     * Find zero or one ProgresTahapan that matches the filter.
     * @param {ProgresTahapanFindUniqueArgs} args - Arguments to find a ProgresTahapan
     * @example
     * // Get one ProgresTahapan
     * const progresTahapan = await prisma.progresTahapan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgresTahapanFindUniqueArgs>(args: SelectSubset<T, ProgresTahapanFindUniqueArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgresTahapan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgresTahapanFindUniqueOrThrowArgs} args - Arguments to find a ProgresTahapan
     * @example
     * // Get one ProgresTahapan
     * const progresTahapan = await prisma.progresTahapan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgresTahapanFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgresTahapanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgresTahapan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresTahapanFindFirstArgs} args - Arguments to find a ProgresTahapan
     * @example
     * // Get one ProgresTahapan
     * const progresTahapan = await prisma.progresTahapan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgresTahapanFindFirstArgs>(args?: SelectSubset<T, ProgresTahapanFindFirstArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgresTahapan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresTahapanFindFirstOrThrowArgs} args - Arguments to find a ProgresTahapan
     * @example
     * // Get one ProgresTahapan
     * const progresTahapan = await prisma.progresTahapan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgresTahapanFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgresTahapanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgresTahapans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresTahapanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgresTahapans
     * const progresTahapans = await prisma.progresTahapan.findMany()
     * 
     * // Get first 10 ProgresTahapans
     * const progresTahapans = await prisma.progresTahapan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progresTahapanWithIdOnly = await prisma.progresTahapan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgresTahapanFindManyArgs>(args?: SelectSubset<T, ProgresTahapanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgresTahapan.
     * @param {ProgresTahapanCreateArgs} args - Arguments to create a ProgresTahapan.
     * @example
     * // Create one ProgresTahapan
     * const ProgresTahapan = await prisma.progresTahapan.create({
     *   data: {
     *     // ... data to create a ProgresTahapan
     *   }
     * })
     * 
     */
    create<T extends ProgresTahapanCreateArgs>(args: SelectSubset<T, ProgresTahapanCreateArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgresTahapans.
     * @param {ProgresTahapanCreateManyArgs} args - Arguments to create many ProgresTahapans.
     * @example
     * // Create many ProgresTahapans
     * const progresTahapan = await prisma.progresTahapan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgresTahapanCreateManyArgs>(args?: SelectSubset<T, ProgresTahapanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProgresTahapan.
     * @param {ProgresTahapanDeleteArgs} args - Arguments to delete one ProgresTahapan.
     * @example
     * // Delete one ProgresTahapan
     * const ProgresTahapan = await prisma.progresTahapan.delete({
     *   where: {
     *     // ... filter to delete one ProgresTahapan
     *   }
     * })
     * 
     */
    delete<T extends ProgresTahapanDeleteArgs>(args: SelectSubset<T, ProgresTahapanDeleteArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgresTahapan.
     * @param {ProgresTahapanUpdateArgs} args - Arguments to update one ProgresTahapan.
     * @example
     * // Update one ProgresTahapan
     * const progresTahapan = await prisma.progresTahapan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgresTahapanUpdateArgs>(args: SelectSubset<T, ProgresTahapanUpdateArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgresTahapans.
     * @param {ProgresTahapanDeleteManyArgs} args - Arguments to filter ProgresTahapans to delete.
     * @example
     * // Delete a few ProgresTahapans
     * const { count } = await prisma.progresTahapan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgresTahapanDeleteManyArgs>(args?: SelectSubset<T, ProgresTahapanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgresTahapans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresTahapanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgresTahapans
     * const progresTahapan = await prisma.progresTahapan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgresTahapanUpdateManyArgs>(args: SelectSubset<T, ProgresTahapanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgresTahapan.
     * @param {ProgresTahapanUpsertArgs} args - Arguments to update or create a ProgresTahapan.
     * @example
     * // Update or create a ProgresTahapan
     * const progresTahapan = await prisma.progresTahapan.upsert({
     *   create: {
     *     // ... data to create a ProgresTahapan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgresTahapan we want to update
     *   }
     * })
     */
    upsert<T extends ProgresTahapanUpsertArgs>(args: SelectSubset<T, ProgresTahapanUpsertArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgresTahapans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresTahapanCountArgs} args - Arguments to filter ProgresTahapans to count.
     * @example
     * // Count the number of ProgresTahapans
     * const count = await prisma.progresTahapan.count({
     *   where: {
     *     // ... the filter for the ProgresTahapans we want to count
     *   }
     * })
    **/
    count<T extends ProgresTahapanCountArgs>(
      args?: Subset<T, ProgresTahapanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgresTahapanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgresTahapan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresTahapanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgresTahapanAggregateArgs>(args: Subset<T, ProgresTahapanAggregateArgs>): Prisma.PrismaPromise<GetProgresTahapanAggregateType<T>>

    /**
     * Group by ProgresTahapan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgresTahapanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgresTahapanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgresTahapanGroupByArgs['orderBy'] }
        : { orderBy?: ProgresTahapanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgresTahapanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgresTahapanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgresTahapan model
   */
  readonly fields: ProgresTahapanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgresTahapan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgresTahapanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaksi<T extends TransaksiPengadaanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransaksiPengadaanDefaultArgs<ExtArgs>>): Prisma__TransaksiPengadaanClient<$Result.GetResult<Prisma.$TransaksiPengadaanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tahapan<T extends TahapanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TahapanDefaultArgs<ExtArgs>>): Prisma__TahapanClient<$Result.GetResult<Prisma.$TahapanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dokumen<T extends ProgresTahapan$dokumenArgs<ExtArgs> = {}>(args?: Subset<T, ProgresTahapan$dokumenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgresTahapan model
   */ 
  interface ProgresTahapanFieldRefs {
    readonly id: FieldRef<"ProgresTahapan", 'Int'>
    readonly transaksiId: FieldRef<"ProgresTahapan", 'Int'>
    readonly tahapanId: FieldRef<"ProgresTahapan", 'Int'>
    readonly status: FieldRef<"ProgresTahapan", 'StatusTahapan'>
    readonly planningTanggalMulai: FieldRef<"ProgresTahapan", 'DateTime'>
    readonly planningTanggalSelesai: FieldRef<"ProgresTahapan", 'DateTime'>
    readonly aktualTanggalMulai: FieldRef<"ProgresTahapan", 'DateTime'>
    readonly aktualTanggalSelesai: FieldRef<"ProgresTahapan", 'DateTime'>
    readonly keterangan: FieldRef<"ProgresTahapan", 'String'>
    readonly updatedAt: FieldRef<"ProgresTahapan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgresTahapan findUnique
   */
  export type ProgresTahapanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which ProgresTahapan to fetch.
     */
    where: ProgresTahapanWhereUniqueInput
  }

  /**
   * ProgresTahapan findUniqueOrThrow
   */
  export type ProgresTahapanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which ProgresTahapan to fetch.
     */
    where: ProgresTahapanWhereUniqueInput
  }

  /**
   * ProgresTahapan findFirst
   */
  export type ProgresTahapanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which ProgresTahapan to fetch.
     */
    where?: ProgresTahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgresTahapans to fetch.
     */
    orderBy?: ProgresTahapanOrderByWithRelationInput | ProgresTahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgresTahapans.
     */
    cursor?: ProgresTahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgresTahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgresTahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgresTahapans.
     */
    distinct?: ProgresTahapanScalarFieldEnum | ProgresTahapanScalarFieldEnum[]
  }

  /**
   * ProgresTahapan findFirstOrThrow
   */
  export type ProgresTahapanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which ProgresTahapan to fetch.
     */
    where?: ProgresTahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgresTahapans to fetch.
     */
    orderBy?: ProgresTahapanOrderByWithRelationInput | ProgresTahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgresTahapans.
     */
    cursor?: ProgresTahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgresTahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgresTahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgresTahapans.
     */
    distinct?: ProgresTahapanScalarFieldEnum | ProgresTahapanScalarFieldEnum[]
  }

  /**
   * ProgresTahapan findMany
   */
  export type ProgresTahapanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which ProgresTahapans to fetch.
     */
    where?: ProgresTahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgresTahapans to fetch.
     */
    orderBy?: ProgresTahapanOrderByWithRelationInput | ProgresTahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgresTahapans.
     */
    cursor?: ProgresTahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgresTahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgresTahapans.
     */
    skip?: number
    distinct?: ProgresTahapanScalarFieldEnum | ProgresTahapanScalarFieldEnum[]
  }

  /**
   * ProgresTahapan create
   */
  export type ProgresTahapanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgresTahapan.
     */
    data: XOR<ProgresTahapanCreateInput, ProgresTahapanUncheckedCreateInput>
  }

  /**
   * ProgresTahapan createMany
   */
  export type ProgresTahapanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgresTahapans.
     */
    data: ProgresTahapanCreateManyInput | ProgresTahapanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgresTahapan update
   */
  export type ProgresTahapanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgresTahapan.
     */
    data: XOR<ProgresTahapanUpdateInput, ProgresTahapanUncheckedUpdateInput>
    /**
     * Choose, which ProgresTahapan to update.
     */
    where: ProgresTahapanWhereUniqueInput
  }

  /**
   * ProgresTahapan updateMany
   */
  export type ProgresTahapanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgresTahapans.
     */
    data: XOR<ProgresTahapanUpdateManyMutationInput, ProgresTahapanUncheckedUpdateManyInput>
    /**
     * Filter which ProgresTahapans to update
     */
    where?: ProgresTahapanWhereInput
  }

  /**
   * ProgresTahapan upsert
   */
  export type ProgresTahapanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgresTahapan to update in case it exists.
     */
    where: ProgresTahapanWhereUniqueInput
    /**
     * In case the ProgresTahapan found by the `where` argument doesn't exist, create a new ProgresTahapan with this data.
     */
    create: XOR<ProgresTahapanCreateInput, ProgresTahapanUncheckedCreateInput>
    /**
     * In case the ProgresTahapan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgresTahapanUpdateInput, ProgresTahapanUncheckedUpdateInput>
  }

  /**
   * ProgresTahapan delete
   */
  export type ProgresTahapanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter which ProgresTahapan to delete.
     */
    where: ProgresTahapanWhereUniqueInput
  }

  /**
   * ProgresTahapan deleteMany
   */
  export type ProgresTahapanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgresTahapans to delete
     */
    where?: ProgresTahapanWhereInput
  }

  /**
   * ProgresTahapan.dokumen
   */
  export type ProgresTahapan$dokumenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    where?: DokumenProgresTahapanWhereInput
    orderBy?: DokumenProgresTahapanOrderByWithRelationInput | DokumenProgresTahapanOrderByWithRelationInput[]
    cursor?: DokumenProgresTahapanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DokumenProgresTahapanScalarFieldEnum | DokumenProgresTahapanScalarFieldEnum[]
  }

  /**
   * ProgresTahapan without action
   */
  export type ProgresTahapanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgresTahapan
     */
    select?: ProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgresTahapanInclude<ExtArgs> | null
  }


  /**
   * Model DokumenProgresTahapan
   */

  export type AggregateDokumenProgresTahapan = {
    _count: DokumenProgresTahapanCountAggregateOutputType | null
    _avg: DokumenProgresTahapanAvgAggregateOutputType | null
    _sum: DokumenProgresTahapanSumAggregateOutputType | null
    _min: DokumenProgresTahapanMinAggregateOutputType | null
    _max: DokumenProgresTahapanMaxAggregateOutputType | null
  }

  export type DokumenProgresTahapanAvgAggregateOutputType = {
    id: number | null
    progresTahapanId: number | null
  }

  export type DokumenProgresTahapanSumAggregateOutputType = {
    id: number | null
    progresTahapanId: number | null
  }

  export type DokumenProgresTahapanMinAggregateOutputType = {
    id: number | null
    progresTahapanId: number | null
    namaFile: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type DokumenProgresTahapanMaxAggregateOutputType = {
    id: number | null
    progresTahapanId: number | null
    namaFile: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type DokumenProgresTahapanCountAggregateOutputType = {
    id: number
    progresTahapanId: number
    namaFile: number
    fileUrl: number
    createdAt: number
    _all: number
  }


  export type DokumenProgresTahapanAvgAggregateInputType = {
    id?: true
    progresTahapanId?: true
  }

  export type DokumenProgresTahapanSumAggregateInputType = {
    id?: true
    progresTahapanId?: true
  }

  export type DokumenProgresTahapanMinAggregateInputType = {
    id?: true
    progresTahapanId?: true
    namaFile?: true
    fileUrl?: true
    createdAt?: true
  }

  export type DokumenProgresTahapanMaxAggregateInputType = {
    id?: true
    progresTahapanId?: true
    namaFile?: true
    fileUrl?: true
    createdAt?: true
  }

  export type DokumenProgresTahapanCountAggregateInputType = {
    id?: true
    progresTahapanId?: true
    namaFile?: true
    fileUrl?: true
    createdAt?: true
    _all?: true
  }

  export type DokumenProgresTahapanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DokumenProgresTahapan to aggregate.
     */
    where?: DokumenProgresTahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DokumenProgresTahapans to fetch.
     */
    orderBy?: DokumenProgresTahapanOrderByWithRelationInput | DokumenProgresTahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DokumenProgresTahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DokumenProgresTahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DokumenProgresTahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DokumenProgresTahapans
    **/
    _count?: true | DokumenProgresTahapanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DokumenProgresTahapanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DokumenProgresTahapanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DokumenProgresTahapanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DokumenProgresTahapanMaxAggregateInputType
  }

  export type GetDokumenProgresTahapanAggregateType<T extends DokumenProgresTahapanAggregateArgs> = {
        [P in keyof T & keyof AggregateDokumenProgresTahapan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDokumenProgresTahapan[P]>
      : GetScalarType<T[P], AggregateDokumenProgresTahapan[P]>
  }




  export type DokumenProgresTahapanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DokumenProgresTahapanWhereInput
    orderBy?: DokumenProgresTahapanOrderByWithAggregationInput | DokumenProgresTahapanOrderByWithAggregationInput[]
    by: DokumenProgresTahapanScalarFieldEnum[] | DokumenProgresTahapanScalarFieldEnum
    having?: DokumenProgresTahapanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DokumenProgresTahapanCountAggregateInputType | true
    _avg?: DokumenProgresTahapanAvgAggregateInputType
    _sum?: DokumenProgresTahapanSumAggregateInputType
    _min?: DokumenProgresTahapanMinAggregateInputType
    _max?: DokumenProgresTahapanMaxAggregateInputType
  }

  export type DokumenProgresTahapanGroupByOutputType = {
    id: number
    progresTahapanId: number
    namaFile: string
    fileUrl: string
    createdAt: Date
    _count: DokumenProgresTahapanCountAggregateOutputType | null
    _avg: DokumenProgresTahapanAvgAggregateOutputType | null
    _sum: DokumenProgresTahapanSumAggregateOutputType | null
    _min: DokumenProgresTahapanMinAggregateOutputType | null
    _max: DokumenProgresTahapanMaxAggregateOutputType | null
  }

  type GetDokumenProgresTahapanGroupByPayload<T extends DokumenProgresTahapanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DokumenProgresTahapanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DokumenProgresTahapanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DokumenProgresTahapanGroupByOutputType[P]>
            : GetScalarType<T[P], DokumenProgresTahapanGroupByOutputType[P]>
        }
      >
    >


  export type DokumenProgresTahapanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progresTahapanId?: boolean
    namaFile?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    progresTahapan?: boolean | ProgresTahapanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dokumenProgresTahapan"]>


  export type DokumenProgresTahapanSelectScalar = {
    id?: boolean
    progresTahapanId?: boolean
    namaFile?: boolean
    fileUrl?: boolean
    createdAt?: boolean
  }

  export type DokumenProgresTahapanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progresTahapan?: boolean | ProgresTahapanDefaultArgs<ExtArgs>
  }

  export type $DokumenProgresTahapanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DokumenProgresTahapan"
    objects: {
      progresTahapan: Prisma.$ProgresTahapanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      progresTahapanId: number
      namaFile: string
      fileUrl: string
      createdAt: Date
    }, ExtArgs["result"]["dokumenProgresTahapan"]>
    composites: {}
  }

  type DokumenProgresTahapanGetPayload<S extends boolean | null | undefined | DokumenProgresTahapanDefaultArgs> = $Result.GetResult<Prisma.$DokumenProgresTahapanPayload, S>

  type DokumenProgresTahapanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DokumenProgresTahapanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DokumenProgresTahapanCountAggregateInputType | true
    }

  export interface DokumenProgresTahapanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DokumenProgresTahapan'], meta: { name: 'DokumenProgresTahapan' } }
    /**
     * Find zero or one DokumenProgresTahapan that matches the filter.
     * @param {DokumenProgresTahapanFindUniqueArgs} args - Arguments to find a DokumenProgresTahapan
     * @example
     * // Get one DokumenProgresTahapan
     * const dokumenProgresTahapan = await prisma.dokumenProgresTahapan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DokumenProgresTahapanFindUniqueArgs>(args: SelectSubset<T, DokumenProgresTahapanFindUniqueArgs<ExtArgs>>): Prisma__DokumenProgresTahapanClient<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DokumenProgresTahapan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DokumenProgresTahapanFindUniqueOrThrowArgs} args - Arguments to find a DokumenProgresTahapan
     * @example
     * // Get one DokumenProgresTahapan
     * const dokumenProgresTahapan = await prisma.dokumenProgresTahapan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DokumenProgresTahapanFindUniqueOrThrowArgs>(args: SelectSubset<T, DokumenProgresTahapanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DokumenProgresTahapanClient<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DokumenProgresTahapan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgresTahapanFindFirstArgs} args - Arguments to find a DokumenProgresTahapan
     * @example
     * // Get one DokumenProgresTahapan
     * const dokumenProgresTahapan = await prisma.dokumenProgresTahapan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DokumenProgresTahapanFindFirstArgs>(args?: SelectSubset<T, DokumenProgresTahapanFindFirstArgs<ExtArgs>>): Prisma__DokumenProgresTahapanClient<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DokumenProgresTahapan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgresTahapanFindFirstOrThrowArgs} args - Arguments to find a DokumenProgresTahapan
     * @example
     * // Get one DokumenProgresTahapan
     * const dokumenProgresTahapan = await prisma.dokumenProgresTahapan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DokumenProgresTahapanFindFirstOrThrowArgs>(args?: SelectSubset<T, DokumenProgresTahapanFindFirstOrThrowArgs<ExtArgs>>): Prisma__DokumenProgresTahapanClient<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DokumenProgresTahapans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgresTahapanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DokumenProgresTahapans
     * const dokumenProgresTahapans = await prisma.dokumenProgresTahapan.findMany()
     * 
     * // Get first 10 DokumenProgresTahapans
     * const dokumenProgresTahapans = await prisma.dokumenProgresTahapan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dokumenProgresTahapanWithIdOnly = await prisma.dokumenProgresTahapan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DokumenProgresTahapanFindManyArgs>(args?: SelectSubset<T, DokumenProgresTahapanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DokumenProgresTahapan.
     * @param {DokumenProgresTahapanCreateArgs} args - Arguments to create a DokumenProgresTahapan.
     * @example
     * // Create one DokumenProgresTahapan
     * const DokumenProgresTahapan = await prisma.dokumenProgresTahapan.create({
     *   data: {
     *     // ... data to create a DokumenProgresTahapan
     *   }
     * })
     * 
     */
    create<T extends DokumenProgresTahapanCreateArgs>(args: SelectSubset<T, DokumenProgresTahapanCreateArgs<ExtArgs>>): Prisma__DokumenProgresTahapanClient<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DokumenProgresTahapans.
     * @param {DokumenProgresTahapanCreateManyArgs} args - Arguments to create many DokumenProgresTahapans.
     * @example
     * // Create many DokumenProgresTahapans
     * const dokumenProgresTahapan = await prisma.dokumenProgresTahapan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DokumenProgresTahapanCreateManyArgs>(args?: SelectSubset<T, DokumenProgresTahapanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DokumenProgresTahapan.
     * @param {DokumenProgresTahapanDeleteArgs} args - Arguments to delete one DokumenProgresTahapan.
     * @example
     * // Delete one DokumenProgresTahapan
     * const DokumenProgresTahapan = await prisma.dokumenProgresTahapan.delete({
     *   where: {
     *     // ... filter to delete one DokumenProgresTahapan
     *   }
     * })
     * 
     */
    delete<T extends DokumenProgresTahapanDeleteArgs>(args: SelectSubset<T, DokumenProgresTahapanDeleteArgs<ExtArgs>>): Prisma__DokumenProgresTahapanClient<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DokumenProgresTahapan.
     * @param {DokumenProgresTahapanUpdateArgs} args - Arguments to update one DokumenProgresTahapan.
     * @example
     * // Update one DokumenProgresTahapan
     * const dokumenProgresTahapan = await prisma.dokumenProgresTahapan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DokumenProgresTahapanUpdateArgs>(args: SelectSubset<T, DokumenProgresTahapanUpdateArgs<ExtArgs>>): Prisma__DokumenProgresTahapanClient<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DokumenProgresTahapans.
     * @param {DokumenProgresTahapanDeleteManyArgs} args - Arguments to filter DokumenProgresTahapans to delete.
     * @example
     * // Delete a few DokumenProgresTahapans
     * const { count } = await prisma.dokumenProgresTahapan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DokumenProgresTahapanDeleteManyArgs>(args?: SelectSubset<T, DokumenProgresTahapanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DokumenProgresTahapans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgresTahapanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DokumenProgresTahapans
     * const dokumenProgresTahapan = await prisma.dokumenProgresTahapan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DokumenProgresTahapanUpdateManyArgs>(args: SelectSubset<T, DokumenProgresTahapanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DokumenProgresTahapan.
     * @param {DokumenProgresTahapanUpsertArgs} args - Arguments to update or create a DokumenProgresTahapan.
     * @example
     * // Update or create a DokumenProgresTahapan
     * const dokumenProgresTahapan = await prisma.dokumenProgresTahapan.upsert({
     *   create: {
     *     // ... data to create a DokumenProgresTahapan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DokumenProgresTahapan we want to update
     *   }
     * })
     */
    upsert<T extends DokumenProgresTahapanUpsertArgs>(args: SelectSubset<T, DokumenProgresTahapanUpsertArgs<ExtArgs>>): Prisma__DokumenProgresTahapanClient<$Result.GetResult<Prisma.$DokumenProgresTahapanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DokumenProgresTahapans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgresTahapanCountArgs} args - Arguments to filter DokumenProgresTahapans to count.
     * @example
     * // Count the number of DokumenProgresTahapans
     * const count = await prisma.dokumenProgresTahapan.count({
     *   where: {
     *     // ... the filter for the DokumenProgresTahapans we want to count
     *   }
     * })
    **/
    count<T extends DokumenProgresTahapanCountArgs>(
      args?: Subset<T, DokumenProgresTahapanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DokumenProgresTahapanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DokumenProgresTahapan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgresTahapanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DokumenProgresTahapanAggregateArgs>(args: Subset<T, DokumenProgresTahapanAggregateArgs>): Prisma.PrismaPromise<GetDokumenProgresTahapanAggregateType<T>>

    /**
     * Group by DokumenProgresTahapan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DokumenProgresTahapanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DokumenProgresTahapanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DokumenProgresTahapanGroupByArgs['orderBy'] }
        : { orderBy?: DokumenProgresTahapanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DokumenProgresTahapanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDokumenProgresTahapanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DokumenProgresTahapan model
   */
  readonly fields: DokumenProgresTahapanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DokumenProgresTahapan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DokumenProgresTahapanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    progresTahapan<T extends ProgresTahapanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgresTahapanDefaultArgs<ExtArgs>>): Prisma__ProgresTahapanClient<$Result.GetResult<Prisma.$ProgresTahapanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DokumenProgresTahapan model
   */ 
  interface DokumenProgresTahapanFieldRefs {
    readonly id: FieldRef<"DokumenProgresTahapan", 'Int'>
    readonly progresTahapanId: FieldRef<"DokumenProgresTahapan", 'Int'>
    readonly namaFile: FieldRef<"DokumenProgresTahapan", 'String'>
    readonly fileUrl: FieldRef<"DokumenProgresTahapan", 'String'>
    readonly createdAt: FieldRef<"DokumenProgresTahapan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DokumenProgresTahapan findUnique
   */
  export type DokumenProgresTahapanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgresTahapan to fetch.
     */
    where: DokumenProgresTahapanWhereUniqueInput
  }

  /**
   * DokumenProgresTahapan findUniqueOrThrow
   */
  export type DokumenProgresTahapanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgresTahapan to fetch.
     */
    where: DokumenProgresTahapanWhereUniqueInput
  }

  /**
   * DokumenProgresTahapan findFirst
   */
  export type DokumenProgresTahapanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgresTahapan to fetch.
     */
    where?: DokumenProgresTahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DokumenProgresTahapans to fetch.
     */
    orderBy?: DokumenProgresTahapanOrderByWithRelationInput | DokumenProgresTahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DokumenProgresTahapans.
     */
    cursor?: DokumenProgresTahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DokumenProgresTahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DokumenProgresTahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DokumenProgresTahapans.
     */
    distinct?: DokumenProgresTahapanScalarFieldEnum | DokumenProgresTahapanScalarFieldEnum[]
  }

  /**
   * DokumenProgresTahapan findFirstOrThrow
   */
  export type DokumenProgresTahapanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgresTahapan to fetch.
     */
    where?: DokumenProgresTahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DokumenProgresTahapans to fetch.
     */
    orderBy?: DokumenProgresTahapanOrderByWithRelationInput | DokumenProgresTahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DokumenProgresTahapans.
     */
    cursor?: DokumenProgresTahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DokumenProgresTahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DokumenProgresTahapans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DokumenProgresTahapans.
     */
    distinct?: DokumenProgresTahapanScalarFieldEnum | DokumenProgresTahapanScalarFieldEnum[]
  }

  /**
   * DokumenProgresTahapan findMany
   */
  export type DokumenProgresTahapanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter, which DokumenProgresTahapans to fetch.
     */
    where?: DokumenProgresTahapanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DokumenProgresTahapans to fetch.
     */
    orderBy?: DokumenProgresTahapanOrderByWithRelationInput | DokumenProgresTahapanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DokumenProgresTahapans.
     */
    cursor?: DokumenProgresTahapanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DokumenProgresTahapans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DokumenProgresTahapans.
     */
    skip?: number
    distinct?: DokumenProgresTahapanScalarFieldEnum | DokumenProgresTahapanScalarFieldEnum[]
  }

  /**
   * DokumenProgresTahapan create
   */
  export type DokumenProgresTahapanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * The data needed to create a DokumenProgresTahapan.
     */
    data: XOR<DokumenProgresTahapanCreateInput, DokumenProgresTahapanUncheckedCreateInput>
  }

  /**
   * DokumenProgresTahapan createMany
   */
  export type DokumenProgresTahapanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DokumenProgresTahapans.
     */
    data: DokumenProgresTahapanCreateManyInput | DokumenProgresTahapanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DokumenProgresTahapan update
   */
  export type DokumenProgresTahapanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * The data needed to update a DokumenProgresTahapan.
     */
    data: XOR<DokumenProgresTahapanUpdateInput, DokumenProgresTahapanUncheckedUpdateInput>
    /**
     * Choose, which DokumenProgresTahapan to update.
     */
    where: DokumenProgresTahapanWhereUniqueInput
  }

  /**
   * DokumenProgresTahapan updateMany
   */
  export type DokumenProgresTahapanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DokumenProgresTahapans.
     */
    data: XOR<DokumenProgresTahapanUpdateManyMutationInput, DokumenProgresTahapanUncheckedUpdateManyInput>
    /**
     * Filter which DokumenProgresTahapans to update
     */
    where?: DokumenProgresTahapanWhereInput
  }

  /**
   * DokumenProgresTahapan upsert
   */
  export type DokumenProgresTahapanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * The filter to search for the DokumenProgresTahapan to update in case it exists.
     */
    where: DokumenProgresTahapanWhereUniqueInput
    /**
     * In case the DokumenProgresTahapan found by the `where` argument doesn't exist, create a new DokumenProgresTahapan with this data.
     */
    create: XOR<DokumenProgresTahapanCreateInput, DokumenProgresTahapanUncheckedCreateInput>
    /**
     * In case the DokumenProgresTahapan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DokumenProgresTahapanUpdateInput, DokumenProgresTahapanUncheckedUpdateInput>
  }

  /**
   * DokumenProgresTahapan delete
   */
  export type DokumenProgresTahapanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
    /**
     * Filter which DokumenProgresTahapan to delete.
     */
    where: DokumenProgresTahapanWhereUniqueInput
  }

  /**
   * DokumenProgresTahapan deleteMany
   */
  export type DokumenProgresTahapanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DokumenProgresTahapans to delete
     */
    where?: DokumenProgresTahapanWhereInput
  }

  /**
   * DokumenProgresTahapan without action
   */
  export type DokumenProgresTahapanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DokumenProgresTahapan
     */
    select?: DokumenProgresTahapanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DokumenProgresTahapanInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    name: 'name',
    role: 'role',
    dinasId: 'dinasId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccessTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    revoked: 'revoked',
    createdAt: 'createdAt'
  };

  export type AccessTokenScalarFieldEnum = (typeof AccessTokenScalarFieldEnum)[keyof typeof AccessTokenScalarFieldEnum]


  export const DinasScalarFieldEnum: {
    id: 'id',
    namaDinas: 'namaDinas',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DinasScalarFieldEnum = (typeof DinasScalarFieldEnum)[keyof typeof DinasScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    namaProgram: 'namaProgram',
    slug: 'slug',
    anggaran: 'anggaran',
    isPrioritas: 'isPrioritas',
    dinasId: 'dinasId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const DokumenProgramScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    namaFile: 'namaFile',
    fileUrl: 'fileUrl',
    createdAt: 'createdAt'
  };

  export type DokumenProgramScalarFieldEnum = (typeof DokumenProgramScalarFieldEnum)[keyof typeof DokumenProgramScalarFieldEnum]


  export const PengadaanScalarFieldEnum: {
    id: 'id',
    namaPengadaan: 'namaPengadaan'
  };

  export type PengadaanScalarFieldEnum = (typeof PengadaanScalarFieldEnum)[keyof typeof PengadaanScalarFieldEnum]


  export const TahapanScalarFieldEnum: {
    id: 'id',
    pengadaanId: 'pengadaanId',
    noUrut: 'noUrut',
    namaTahapan: 'namaTahapan',
    standarWaktuHari: 'standarWaktuHari',
    isWaktuEditable: 'isWaktuEditable',
    bobot: 'bobot'
  };

  export type TahapanScalarFieldEnum = (typeof TahapanScalarFieldEnum)[keyof typeof TahapanScalarFieldEnum]


  export const TransaksiPengadaanScalarFieldEnum: {
    id: 'id',
    namaTransaksi: 'namaTransaksi',
    title: 'title',
    programId: 'programId',
    pengadaanId: 'pengadaanId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransaksiPengadaanScalarFieldEnum = (typeof TransaksiPengadaanScalarFieldEnum)[keyof typeof TransaksiPengadaanScalarFieldEnum]


  export const ProgresTahapanScalarFieldEnum: {
    id: 'id',
    transaksiId: 'transaksiId',
    tahapanId: 'tahapanId',
    status: 'status',
    planningTanggalMulai: 'planningTanggalMulai',
    planningTanggalSelesai: 'planningTanggalSelesai',
    aktualTanggalMulai: 'aktualTanggalMulai',
    aktualTanggalSelesai: 'aktualTanggalSelesai',
    keterangan: 'keterangan',
    updatedAt: 'updatedAt'
  };

  export type ProgresTahapanScalarFieldEnum = (typeof ProgresTahapanScalarFieldEnum)[keyof typeof ProgresTahapanScalarFieldEnum]


  export const DokumenProgresTahapanScalarFieldEnum: {
    id: 'id',
    progresTahapanId: 'progresTahapanId',
    namaFile: 'namaFile',
    fileUrl: 'fileUrl',
    createdAt: 'createdAt'
  };

  export type DokumenProgresTahapanScalarFieldEnum = (typeof DokumenProgresTahapanScalarFieldEnum)[keyof typeof DokumenProgresTahapanScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'StatusTahapan'
   */
  export type EnumStatusTahapanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusTahapan'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    dinasId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    dinas?: XOR<DinasNullableRelationFilter, DinasWhereInput> | null
    accessTokens?: AccessTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    dinasId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dinas?: DinasOrderByWithRelationInput
    accessTokens?: AccessTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    dinasId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    dinas?: XOR<DinasNullableRelationFilter, DinasWhereInput> | null
    accessTokens?: AccessTokenListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    dinasId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    dinasId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccessTokenWhereInput = {
    AND?: AccessTokenWhereInput | AccessTokenWhereInput[]
    OR?: AccessTokenWhereInput[]
    NOT?: AccessTokenWhereInput | AccessTokenWhereInput[]
    id?: IntFilter<"AccessToken"> | number
    token?: StringFilter<"AccessToken"> | string
    userId?: IntFilter<"AccessToken"> | number
    expiresAt?: DateTimeNullableFilter<"AccessToken"> | Date | string | null
    revoked?: BoolFilter<"AccessToken"> | boolean
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccessTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccessTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: AccessTokenWhereInput | AccessTokenWhereInput[]
    OR?: AccessTokenWhereInput[]
    NOT?: AccessTokenWhereInput | AccessTokenWhereInput[]
    userId?: IntFilter<"AccessToken"> | number
    expiresAt?: DateTimeNullableFilter<"AccessToken"> | Date | string | null
    revoked?: BoolFilter<"AccessToken"> | boolean
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type AccessTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    _count?: AccessTokenCountOrderByAggregateInput
    _avg?: AccessTokenAvgOrderByAggregateInput
    _max?: AccessTokenMaxOrderByAggregateInput
    _min?: AccessTokenMinOrderByAggregateInput
    _sum?: AccessTokenSumOrderByAggregateInput
  }

  export type AccessTokenScalarWhereWithAggregatesInput = {
    AND?: AccessTokenScalarWhereWithAggregatesInput | AccessTokenScalarWhereWithAggregatesInput[]
    OR?: AccessTokenScalarWhereWithAggregatesInput[]
    NOT?: AccessTokenScalarWhereWithAggregatesInput | AccessTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccessToken"> | number
    token?: StringWithAggregatesFilter<"AccessToken"> | string
    userId?: IntWithAggregatesFilter<"AccessToken"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AccessToken"> | Date | string | null
    revoked?: BoolWithAggregatesFilter<"AccessToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AccessToken"> | Date | string
  }

  export type DinasWhereInput = {
    AND?: DinasWhereInput | DinasWhereInput[]
    OR?: DinasWhereInput[]
    NOT?: DinasWhereInput | DinasWhereInput[]
    id?: IntFilter<"Dinas"> | number
    namaDinas?: StringFilter<"Dinas"> | string
    slug?: StringFilter<"Dinas"> | string
    createdAt?: DateTimeFilter<"Dinas"> | Date | string
    updatedAt?: DateTimeFilter<"Dinas"> | Date | string
    users?: UserListRelationFilter
    programs?: ProgramListRelationFilter
  }

  export type DinasOrderByWithRelationInput = {
    id?: SortOrder
    namaDinas?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    programs?: ProgramOrderByRelationAggregateInput
  }

  export type DinasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    namaDinas?: string
    slug?: string
    AND?: DinasWhereInput | DinasWhereInput[]
    OR?: DinasWhereInput[]
    NOT?: DinasWhereInput | DinasWhereInput[]
    createdAt?: DateTimeFilter<"Dinas"> | Date | string
    updatedAt?: DateTimeFilter<"Dinas"> | Date | string
    users?: UserListRelationFilter
    programs?: ProgramListRelationFilter
  }, "id" | "namaDinas" | "slug">

  export type DinasOrderByWithAggregationInput = {
    id?: SortOrder
    namaDinas?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DinasCountOrderByAggregateInput
    _avg?: DinasAvgOrderByAggregateInput
    _max?: DinasMaxOrderByAggregateInput
    _min?: DinasMinOrderByAggregateInput
    _sum?: DinasSumOrderByAggregateInput
  }

  export type DinasScalarWhereWithAggregatesInput = {
    AND?: DinasScalarWhereWithAggregatesInput | DinasScalarWhereWithAggregatesInput[]
    OR?: DinasScalarWhereWithAggregatesInput[]
    NOT?: DinasScalarWhereWithAggregatesInput | DinasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Dinas"> | number
    namaDinas?: StringWithAggregatesFilter<"Dinas"> | string
    slug?: StringWithAggregatesFilter<"Dinas"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Dinas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dinas"> | Date | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: IntFilter<"Program"> | number
    namaProgram?: StringFilter<"Program"> | string
    slug?: StringFilter<"Program"> | string
    anggaran?: BigIntFilter<"Program"> | bigint | number
    isPrioritas?: BoolFilter<"Program"> | boolean
    dinasId?: IntFilter<"Program"> | number
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    dinas?: XOR<DinasRelationFilter, DinasWhereInput>
    pengadaan?: TransaksiPengadaanListRelationFilter
    dokumen?: DokumenProgramListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    namaProgram?: SortOrder
    slug?: SortOrder
    anggaran?: SortOrder
    isPrioritas?: SortOrder
    dinasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dinas?: DinasOrderByWithRelationInput
    pengadaan?: TransaksiPengadaanOrderByRelationAggregateInput
    dokumen?: DokumenProgramOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    namaProgram?: StringFilter<"Program"> | string
    anggaran?: BigIntFilter<"Program"> | bigint | number
    isPrioritas?: BoolFilter<"Program"> | boolean
    dinasId?: IntFilter<"Program"> | number
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    dinas?: XOR<DinasRelationFilter, DinasWhereInput>
    pengadaan?: TransaksiPengadaanListRelationFilter
    dokumen?: DokumenProgramListRelationFilter
  }, "id" | "slug">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    namaProgram?: SortOrder
    slug?: SortOrder
    anggaran?: SortOrder
    isPrioritas?: SortOrder
    dinasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Program"> | number
    namaProgram?: StringWithAggregatesFilter<"Program"> | string
    slug?: StringWithAggregatesFilter<"Program"> | string
    anggaran?: BigIntWithAggregatesFilter<"Program"> | bigint | number
    isPrioritas?: BoolWithAggregatesFilter<"Program"> | boolean
    dinasId?: IntWithAggregatesFilter<"Program"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
  }

  export type DokumenProgramWhereInput = {
    AND?: DokumenProgramWhereInput | DokumenProgramWhereInput[]
    OR?: DokumenProgramWhereInput[]
    NOT?: DokumenProgramWhereInput | DokumenProgramWhereInput[]
    id?: IntFilter<"DokumenProgram"> | number
    programId?: IntFilter<"DokumenProgram"> | number
    namaFile?: StringFilter<"DokumenProgram"> | string
    fileUrl?: StringFilter<"DokumenProgram"> | string
    createdAt?: DateTimeFilter<"DokumenProgram"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
  }

  export type DokumenProgramOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    program?: ProgramOrderByWithRelationInput
  }

  export type DokumenProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DokumenProgramWhereInput | DokumenProgramWhereInput[]
    OR?: DokumenProgramWhereInput[]
    NOT?: DokumenProgramWhereInput | DokumenProgramWhereInput[]
    programId?: IntFilter<"DokumenProgram"> | number
    namaFile?: StringFilter<"DokumenProgram"> | string
    fileUrl?: StringFilter<"DokumenProgram"> | string
    createdAt?: DateTimeFilter<"DokumenProgram"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
  }, "id">

  export type DokumenProgramOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    _count?: DokumenProgramCountOrderByAggregateInput
    _avg?: DokumenProgramAvgOrderByAggregateInput
    _max?: DokumenProgramMaxOrderByAggregateInput
    _min?: DokumenProgramMinOrderByAggregateInput
    _sum?: DokumenProgramSumOrderByAggregateInput
  }

  export type DokumenProgramScalarWhereWithAggregatesInput = {
    AND?: DokumenProgramScalarWhereWithAggregatesInput | DokumenProgramScalarWhereWithAggregatesInput[]
    OR?: DokumenProgramScalarWhereWithAggregatesInput[]
    NOT?: DokumenProgramScalarWhereWithAggregatesInput | DokumenProgramScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DokumenProgram"> | number
    programId?: IntWithAggregatesFilter<"DokumenProgram"> | number
    namaFile?: StringWithAggregatesFilter<"DokumenProgram"> | string
    fileUrl?: StringWithAggregatesFilter<"DokumenProgram"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DokumenProgram"> | Date | string
  }

  export type PengadaanWhereInput = {
    AND?: PengadaanWhereInput | PengadaanWhereInput[]
    OR?: PengadaanWhereInput[]
    NOT?: PengadaanWhereInput | PengadaanWhereInput[]
    id?: IntFilter<"Pengadaan"> | number
    namaPengadaan?: StringFilter<"Pengadaan"> | string
    tahapan?: TahapanListRelationFilter
    transaksi?: TransaksiPengadaanListRelationFilter
  }

  export type PengadaanOrderByWithRelationInput = {
    id?: SortOrder
    namaPengadaan?: SortOrder
    tahapan?: TahapanOrderByRelationAggregateInput
    transaksi?: TransaksiPengadaanOrderByRelationAggregateInput
  }

  export type PengadaanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    namaPengadaan?: string
    AND?: PengadaanWhereInput | PengadaanWhereInput[]
    OR?: PengadaanWhereInput[]
    NOT?: PengadaanWhereInput | PengadaanWhereInput[]
    tahapan?: TahapanListRelationFilter
    transaksi?: TransaksiPengadaanListRelationFilter
  }, "id" | "namaPengadaan">

  export type PengadaanOrderByWithAggregationInput = {
    id?: SortOrder
    namaPengadaan?: SortOrder
    _count?: PengadaanCountOrderByAggregateInput
    _avg?: PengadaanAvgOrderByAggregateInput
    _max?: PengadaanMaxOrderByAggregateInput
    _min?: PengadaanMinOrderByAggregateInput
    _sum?: PengadaanSumOrderByAggregateInput
  }

  export type PengadaanScalarWhereWithAggregatesInput = {
    AND?: PengadaanScalarWhereWithAggregatesInput | PengadaanScalarWhereWithAggregatesInput[]
    OR?: PengadaanScalarWhereWithAggregatesInput[]
    NOT?: PengadaanScalarWhereWithAggregatesInput | PengadaanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pengadaan"> | number
    namaPengadaan?: StringWithAggregatesFilter<"Pengadaan"> | string
  }

  export type TahapanWhereInput = {
    AND?: TahapanWhereInput | TahapanWhereInput[]
    OR?: TahapanWhereInput[]
    NOT?: TahapanWhereInput | TahapanWhereInput[]
    id?: IntFilter<"Tahapan"> | number
    pengadaanId?: IntFilter<"Tahapan"> | number
    noUrut?: IntFilter<"Tahapan"> | number
    namaTahapan?: StringFilter<"Tahapan"> | string
    standarWaktuHari?: IntNullableFilter<"Tahapan"> | number | null
    isWaktuEditable?: BoolFilter<"Tahapan"> | boolean
    bobot?: IntFilter<"Tahapan"> | number
    pengadaan?: XOR<PengadaanRelationFilter, PengadaanWhereInput>
    progresTahapan?: ProgresTahapanListRelationFilter
  }

  export type TahapanOrderByWithRelationInput = {
    id?: SortOrder
    pengadaanId?: SortOrder
    noUrut?: SortOrder
    namaTahapan?: SortOrder
    standarWaktuHari?: SortOrderInput | SortOrder
    isWaktuEditable?: SortOrder
    bobot?: SortOrder
    pengadaan?: PengadaanOrderByWithRelationInput
    progresTahapan?: ProgresTahapanOrderByRelationAggregateInput
  }

  export type TahapanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TahapanWhereInput | TahapanWhereInput[]
    OR?: TahapanWhereInput[]
    NOT?: TahapanWhereInput | TahapanWhereInput[]
    pengadaanId?: IntFilter<"Tahapan"> | number
    noUrut?: IntFilter<"Tahapan"> | number
    namaTahapan?: StringFilter<"Tahapan"> | string
    standarWaktuHari?: IntNullableFilter<"Tahapan"> | number | null
    isWaktuEditable?: BoolFilter<"Tahapan"> | boolean
    bobot?: IntFilter<"Tahapan"> | number
    pengadaan?: XOR<PengadaanRelationFilter, PengadaanWhereInput>
    progresTahapan?: ProgresTahapanListRelationFilter
  }, "id">

  export type TahapanOrderByWithAggregationInput = {
    id?: SortOrder
    pengadaanId?: SortOrder
    noUrut?: SortOrder
    namaTahapan?: SortOrder
    standarWaktuHari?: SortOrderInput | SortOrder
    isWaktuEditable?: SortOrder
    bobot?: SortOrder
    _count?: TahapanCountOrderByAggregateInput
    _avg?: TahapanAvgOrderByAggregateInput
    _max?: TahapanMaxOrderByAggregateInput
    _min?: TahapanMinOrderByAggregateInput
    _sum?: TahapanSumOrderByAggregateInput
  }

  export type TahapanScalarWhereWithAggregatesInput = {
    AND?: TahapanScalarWhereWithAggregatesInput | TahapanScalarWhereWithAggregatesInput[]
    OR?: TahapanScalarWhereWithAggregatesInput[]
    NOT?: TahapanScalarWhereWithAggregatesInput | TahapanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tahapan"> | number
    pengadaanId?: IntWithAggregatesFilter<"Tahapan"> | number
    noUrut?: IntWithAggregatesFilter<"Tahapan"> | number
    namaTahapan?: StringWithAggregatesFilter<"Tahapan"> | string
    standarWaktuHari?: IntNullableWithAggregatesFilter<"Tahapan"> | number | null
    isWaktuEditable?: BoolWithAggregatesFilter<"Tahapan"> | boolean
    bobot?: IntWithAggregatesFilter<"Tahapan"> | number
  }

  export type TransaksiPengadaanWhereInput = {
    AND?: TransaksiPengadaanWhereInput | TransaksiPengadaanWhereInput[]
    OR?: TransaksiPengadaanWhereInput[]
    NOT?: TransaksiPengadaanWhereInput | TransaksiPengadaanWhereInput[]
    id?: IntFilter<"TransaksiPengadaan"> | number
    namaTransaksi?: StringFilter<"TransaksiPengadaan"> | string
    title?: StringFilter<"TransaksiPengadaan"> | string
    programId?: IntFilter<"TransaksiPengadaan"> | number
    pengadaanId?: IntFilter<"TransaksiPengadaan"> | number
    createdAt?: DateTimeFilter<"TransaksiPengadaan"> | Date | string
    updatedAt?: DateTimeFilter<"TransaksiPengadaan"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    pengadaan?: XOR<PengadaanRelationFilter, PengadaanWhereInput>
    progresTahapan?: ProgresTahapanListRelationFilter
  }

  export type TransaksiPengadaanOrderByWithRelationInput = {
    id?: SortOrder
    namaTransaksi?: SortOrder
    title?: SortOrder
    programId?: SortOrder
    pengadaanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program?: ProgramOrderByWithRelationInput
    pengadaan?: PengadaanOrderByWithRelationInput
    progresTahapan?: ProgresTahapanOrderByRelationAggregateInput
  }

  export type TransaksiPengadaanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransaksiPengadaanWhereInput | TransaksiPengadaanWhereInput[]
    OR?: TransaksiPengadaanWhereInput[]
    NOT?: TransaksiPengadaanWhereInput | TransaksiPengadaanWhereInput[]
    namaTransaksi?: StringFilter<"TransaksiPengadaan"> | string
    title?: StringFilter<"TransaksiPengadaan"> | string
    programId?: IntFilter<"TransaksiPengadaan"> | number
    pengadaanId?: IntFilter<"TransaksiPengadaan"> | number
    createdAt?: DateTimeFilter<"TransaksiPengadaan"> | Date | string
    updatedAt?: DateTimeFilter<"TransaksiPengadaan"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    pengadaan?: XOR<PengadaanRelationFilter, PengadaanWhereInput>
    progresTahapan?: ProgresTahapanListRelationFilter
  }, "id">

  export type TransaksiPengadaanOrderByWithAggregationInput = {
    id?: SortOrder
    namaTransaksi?: SortOrder
    title?: SortOrder
    programId?: SortOrder
    pengadaanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransaksiPengadaanCountOrderByAggregateInput
    _avg?: TransaksiPengadaanAvgOrderByAggregateInput
    _max?: TransaksiPengadaanMaxOrderByAggregateInput
    _min?: TransaksiPengadaanMinOrderByAggregateInput
    _sum?: TransaksiPengadaanSumOrderByAggregateInput
  }

  export type TransaksiPengadaanScalarWhereWithAggregatesInput = {
    AND?: TransaksiPengadaanScalarWhereWithAggregatesInput | TransaksiPengadaanScalarWhereWithAggregatesInput[]
    OR?: TransaksiPengadaanScalarWhereWithAggregatesInput[]
    NOT?: TransaksiPengadaanScalarWhereWithAggregatesInput | TransaksiPengadaanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransaksiPengadaan"> | number
    namaTransaksi?: StringWithAggregatesFilter<"TransaksiPengadaan"> | string
    title?: StringWithAggregatesFilter<"TransaksiPengadaan"> | string
    programId?: IntWithAggregatesFilter<"TransaksiPengadaan"> | number
    pengadaanId?: IntWithAggregatesFilter<"TransaksiPengadaan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TransaksiPengadaan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransaksiPengadaan"> | Date | string
  }

  export type ProgresTahapanWhereInput = {
    AND?: ProgresTahapanWhereInput | ProgresTahapanWhereInput[]
    OR?: ProgresTahapanWhereInput[]
    NOT?: ProgresTahapanWhereInput | ProgresTahapanWhereInput[]
    id?: IntFilter<"ProgresTahapan"> | number
    transaksiId?: IntFilter<"ProgresTahapan"> | number
    tahapanId?: IntFilter<"ProgresTahapan"> | number
    status?: EnumStatusTahapanFilter<"ProgresTahapan"> | $Enums.StatusTahapan
    planningTanggalMulai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    planningTanggalSelesai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    aktualTanggalMulai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    aktualTanggalSelesai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    keterangan?: StringNullableFilter<"ProgresTahapan"> | string | null
    updatedAt?: DateTimeFilter<"ProgresTahapan"> | Date | string
    transaksi?: XOR<TransaksiPengadaanRelationFilter, TransaksiPengadaanWhereInput>
    tahapan?: XOR<TahapanRelationFilter, TahapanWhereInput>
    dokumen?: DokumenProgresTahapanListRelationFilter
  }

  export type ProgresTahapanOrderByWithRelationInput = {
    id?: SortOrder
    transaksiId?: SortOrder
    tahapanId?: SortOrder
    status?: SortOrder
    planningTanggalMulai?: SortOrderInput | SortOrder
    planningTanggalSelesai?: SortOrderInput | SortOrder
    aktualTanggalMulai?: SortOrderInput | SortOrder
    aktualTanggalSelesai?: SortOrderInput | SortOrder
    keterangan?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    transaksi?: TransaksiPengadaanOrderByWithRelationInput
    tahapan?: TahapanOrderByWithRelationInput
    dokumen?: DokumenProgresTahapanOrderByRelationAggregateInput
  }

  export type ProgresTahapanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transaksiId_tahapanId?: ProgresTahapanTransaksiIdTahapanIdCompoundUniqueInput
    AND?: ProgresTahapanWhereInput | ProgresTahapanWhereInput[]
    OR?: ProgresTahapanWhereInput[]
    NOT?: ProgresTahapanWhereInput | ProgresTahapanWhereInput[]
    transaksiId?: IntFilter<"ProgresTahapan"> | number
    tahapanId?: IntFilter<"ProgresTahapan"> | number
    status?: EnumStatusTahapanFilter<"ProgresTahapan"> | $Enums.StatusTahapan
    planningTanggalMulai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    planningTanggalSelesai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    aktualTanggalMulai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    aktualTanggalSelesai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    keterangan?: StringNullableFilter<"ProgresTahapan"> | string | null
    updatedAt?: DateTimeFilter<"ProgresTahapan"> | Date | string
    transaksi?: XOR<TransaksiPengadaanRelationFilter, TransaksiPengadaanWhereInput>
    tahapan?: XOR<TahapanRelationFilter, TahapanWhereInput>
    dokumen?: DokumenProgresTahapanListRelationFilter
  }, "id" | "transaksiId_tahapanId">

  export type ProgresTahapanOrderByWithAggregationInput = {
    id?: SortOrder
    transaksiId?: SortOrder
    tahapanId?: SortOrder
    status?: SortOrder
    planningTanggalMulai?: SortOrderInput | SortOrder
    planningTanggalSelesai?: SortOrderInput | SortOrder
    aktualTanggalMulai?: SortOrderInput | SortOrder
    aktualTanggalSelesai?: SortOrderInput | SortOrder
    keterangan?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: ProgresTahapanCountOrderByAggregateInput
    _avg?: ProgresTahapanAvgOrderByAggregateInput
    _max?: ProgresTahapanMaxOrderByAggregateInput
    _min?: ProgresTahapanMinOrderByAggregateInput
    _sum?: ProgresTahapanSumOrderByAggregateInput
  }

  export type ProgresTahapanScalarWhereWithAggregatesInput = {
    AND?: ProgresTahapanScalarWhereWithAggregatesInput | ProgresTahapanScalarWhereWithAggregatesInput[]
    OR?: ProgresTahapanScalarWhereWithAggregatesInput[]
    NOT?: ProgresTahapanScalarWhereWithAggregatesInput | ProgresTahapanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProgresTahapan"> | number
    transaksiId?: IntWithAggregatesFilter<"ProgresTahapan"> | number
    tahapanId?: IntWithAggregatesFilter<"ProgresTahapan"> | number
    status?: EnumStatusTahapanWithAggregatesFilter<"ProgresTahapan"> | $Enums.StatusTahapan
    planningTanggalMulai?: DateTimeNullableWithAggregatesFilter<"ProgresTahapan"> | Date | string | null
    planningTanggalSelesai?: DateTimeNullableWithAggregatesFilter<"ProgresTahapan"> | Date | string | null
    aktualTanggalMulai?: DateTimeNullableWithAggregatesFilter<"ProgresTahapan"> | Date | string | null
    aktualTanggalSelesai?: DateTimeNullableWithAggregatesFilter<"ProgresTahapan"> | Date | string | null
    keterangan?: StringNullableWithAggregatesFilter<"ProgresTahapan"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"ProgresTahapan"> | Date | string
  }

  export type DokumenProgresTahapanWhereInput = {
    AND?: DokumenProgresTahapanWhereInput | DokumenProgresTahapanWhereInput[]
    OR?: DokumenProgresTahapanWhereInput[]
    NOT?: DokumenProgresTahapanWhereInput | DokumenProgresTahapanWhereInput[]
    id?: IntFilter<"DokumenProgresTahapan"> | number
    progresTahapanId?: IntFilter<"DokumenProgresTahapan"> | number
    namaFile?: StringFilter<"DokumenProgresTahapan"> | string
    fileUrl?: StringFilter<"DokumenProgresTahapan"> | string
    createdAt?: DateTimeFilter<"DokumenProgresTahapan"> | Date | string
    progresTahapan?: XOR<ProgresTahapanRelationFilter, ProgresTahapanWhereInput>
  }

  export type DokumenProgresTahapanOrderByWithRelationInput = {
    id?: SortOrder
    progresTahapanId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    progresTahapan?: ProgresTahapanOrderByWithRelationInput
  }

  export type DokumenProgresTahapanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DokumenProgresTahapanWhereInput | DokumenProgresTahapanWhereInput[]
    OR?: DokumenProgresTahapanWhereInput[]
    NOT?: DokumenProgresTahapanWhereInput | DokumenProgresTahapanWhereInput[]
    progresTahapanId?: IntFilter<"DokumenProgresTahapan"> | number
    namaFile?: StringFilter<"DokumenProgresTahapan"> | string
    fileUrl?: StringFilter<"DokumenProgresTahapan"> | string
    createdAt?: DateTimeFilter<"DokumenProgresTahapan"> | Date | string
    progresTahapan?: XOR<ProgresTahapanRelationFilter, ProgresTahapanWhereInput>
  }, "id">

  export type DokumenProgresTahapanOrderByWithAggregationInput = {
    id?: SortOrder
    progresTahapanId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    _count?: DokumenProgresTahapanCountOrderByAggregateInput
    _avg?: DokumenProgresTahapanAvgOrderByAggregateInput
    _max?: DokumenProgresTahapanMaxOrderByAggregateInput
    _min?: DokumenProgresTahapanMinOrderByAggregateInput
    _sum?: DokumenProgresTahapanSumOrderByAggregateInput
  }

  export type DokumenProgresTahapanScalarWhereWithAggregatesInput = {
    AND?: DokumenProgresTahapanScalarWhereWithAggregatesInput | DokumenProgresTahapanScalarWhereWithAggregatesInput[]
    OR?: DokumenProgresTahapanScalarWhereWithAggregatesInput[]
    NOT?: DokumenProgresTahapanScalarWhereWithAggregatesInput | DokumenProgresTahapanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DokumenProgresTahapan"> | number
    progresTahapanId?: IntWithAggregatesFilter<"DokumenProgresTahapan"> | number
    namaFile?: StringWithAggregatesFilter<"DokumenProgresTahapan"> | string
    fileUrl?: StringWithAggregatesFilter<"DokumenProgresTahapan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DokumenProgresTahapan"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    name?: string | null
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    dinas?: DinasCreateNestedOneWithoutUsersInput
    accessTokens?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    role: $Enums.Role
    dinasId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dinas?: DinasUpdateOneWithoutUsersNestedInput
    accessTokens?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    dinasId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    role: $Enums.Role
    dinasId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    dinasId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenCreateInput = {
    token: string
    expiresAt?: Date | string | null
    revoked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAccessTokensInput
  }

  export type AccessTokenUncheckedCreateInput = {
    id?: number
    token: string
    userId: number
    expiresAt?: Date | string | null
    revoked?: boolean
    createdAt?: Date | string
  }

  export type AccessTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccessTokensNestedInput
  }

  export type AccessTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenCreateManyInput = {
    id?: number
    token: string
    userId: number
    expiresAt?: Date | string | null
    revoked?: boolean
    createdAt?: Date | string
  }

  export type AccessTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DinasCreateInput = {
    namaDinas: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDinasInput
    programs?: ProgramCreateNestedManyWithoutDinasInput
  }

  export type DinasUncheckedCreateInput = {
    id?: number
    namaDinas: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDinasInput
    programs?: ProgramUncheckedCreateNestedManyWithoutDinasInput
  }

  export type DinasUpdateInput = {
    namaDinas?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDinasNestedInput
    programs?: ProgramUpdateManyWithoutDinasNestedInput
  }

  export type DinasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaDinas?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDinasNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutDinasNestedInput
  }

  export type DinasCreateManyInput = {
    id?: number
    namaDinas: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DinasUpdateManyMutationInput = {
    namaDinas?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DinasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaDinas?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateInput = {
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dinas: DinasCreateNestedOneWithoutProgramsInput
    pengadaan?: TransaksiPengadaanCreateNestedManyWithoutProgramInput
    dokumen?: DokumenProgramCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: number
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    dinasId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pengadaan?: TransaksiPengadaanUncheckedCreateNestedManyWithoutProgramInput
    dokumen?: DokumenProgramUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dinas?: DinasUpdateOneRequiredWithoutProgramsNestedInput
    pengadaan?: TransaksiPengadaanUpdateManyWithoutProgramNestedInput
    dokumen?: DokumenProgramUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    dinasId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pengadaan?: TransaksiPengadaanUncheckedUpdateManyWithoutProgramNestedInput
    dokumen?: DokumenProgramUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: number
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    dinasId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    dinasId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgramCreateInput = {
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
    program: ProgramCreateNestedOneWithoutDokumenInput
  }

  export type DokumenProgramUncheckedCreateInput = {
    id?: number
    programId: number
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgramUpdateInput = {
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutDokumenNestedInput
  }

  export type DokumenProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgramCreateManyInput = {
    id?: number
    programId: number
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgramUpdateManyMutationInput = {
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengadaanCreateInput = {
    namaPengadaan: string
    tahapan?: TahapanCreateNestedManyWithoutPengadaanInput
    transaksi?: TransaksiPengadaanCreateNestedManyWithoutPengadaanInput
  }

  export type PengadaanUncheckedCreateInput = {
    id?: number
    namaPengadaan: string
    tahapan?: TahapanUncheckedCreateNestedManyWithoutPengadaanInput
    transaksi?: TransaksiPengadaanUncheckedCreateNestedManyWithoutPengadaanInput
  }

  export type PengadaanUpdateInput = {
    namaPengadaan?: StringFieldUpdateOperationsInput | string
    tahapan?: TahapanUpdateManyWithoutPengadaanNestedInput
    transaksi?: TransaksiPengadaanUpdateManyWithoutPengadaanNestedInput
  }

  export type PengadaanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaPengadaan?: StringFieldUpdateOperationsInput | string
    tahapan?: TahapanUncheckedUpdateManyWithoutPengadaanNestedInput
    transaksi?: TransaksiPengadaanUncheckedUpdateManyWithoutPengadaanNestedInput
  }

  export type PengadaanCreateManyInput = {
    id?: number
    namaPengadaan: string
  }

  export type PengadaanUpdateManyMutationInput = {
    namaPengadaan?: StringFieldUpdateOperationsInput | string
  }

  export type PengadaanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaPengadaan?: StringFieldUpdateOperationsInput | string
  }

  export type TahapanCreateInput = {
    noUrut: number
    namaTahapan: string
    standarWaktuHari?: number | null
    isWaktuEditable?: boolean
    bobot: number
    pengadaan: PengadaanCreateNestedOneWithoutTahapanInput
    progresTahapan?: ProgresTahapanCreateNestedManyWithoutTahapanInput
  }

  export type TahapanUncheckedCreateInput = {
    id?: number
    pengadaanId: number
    noUrut: number
    namaTahapan: string
    standarWaktuHari?: number | null
    isWaktuEditable?: boolean
    bobot: number
    progresTahapan?: ProgresTahapanUncheckedCreateNestedManyWithoutTahapanInput
  }

  export type TahapanUpdateInput = {
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
    pengadaan?: PengadaanUpdateOneRequiredWithoutTahapanNestedInput
    progresTahapan?: ProgresTahapanUpdateManyWithoutTahapanNestedInput
  }

  export type TahapanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengadaanId?: IntFieldUpdateOperationsInput | number
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
    progresTahapan?: ProgresTahapanUncheckedUpdateManyWithoutTahapanNestedInput
  }

  export type TahapanCreateManyInput = {
    id?: number
    pengadaanId: number
    noUrut: number
    namaTahapan: string
    standarWaktuHari?: number | null
    isWaktuEditable?: boolean
    bobot: number
  }

  export type TahapanUpdateManyMutationInput = {
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
  }

  export type TahapanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengadaanId?: IntFieldUpdateOperationsInput | number
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
  }

  export type TransaksiPengadaanCreateInput = {
    namaTransaksi: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutPengadaanInput
    pengadaan: PengadaanCreateNestedOneWithoutTransaksiInput
    progresTahapan?: ProgresTahapanCreateNestedManyWithoutTransaksiInput
  }

  export type TransaksiPengadaanUncheckedCreateInput = {
    id?: number
    namaTransaksi: string
    title: string
    programId: number
    pengadaanId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    progresTahapan?: ProgresTahapanUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type TransaksiPengadaanUpdateInput = {
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutPengadaanNestedInput
    pengadaan?: PengadaanUpdateOneRequiredWithoutTransaksiNestedInput
    progresTahapan?: ProgresTahapanUpdateManyWithoutTransaksiNestedInput
  }

  export type TransaksiPengadaanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    pengadaanId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progresTahapan?: ProgresTahapanUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type TransaksiPengadaanCreateManyInput = {
    id?: number
    namaTransaksi: string
    title: string
    programId: number
    pengadaanId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransaksiPengadaanUpdateManyMutationInput = {
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransaksiPengadaanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    pengadaanId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresTahapanCreateInput = {
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
    transaksi: TransaksiPengadaanCreateNestedOneWithoutProgresTahapanInput
    tahapan: TahapanCreateNestedOneWithoutProgresTahapanInput
    dokumen?: DokumenProgresTahapanCreateNestedManyWithoutProgresTahapanInput
  }

  export type ProgresTahapanUncheckedCreateInput = {
    id?: number
    transaksiId: number
    tahapanId: number
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
    dokumen?: DokumenProgresTahapanUncheckedCreateNestedManyWithoutProgresTahapanInput
  }

  export type ProgresTahapanUpdateInput = {
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaksi?: TransaksiPengadaanUpdateOneRequiredWithoutProgresTahapanNestedInput
    tahapan?: TahapanUpdateOneRequiredWithoutProgresTahapanNestedInput
    dokumen?: DokumenProgresTahapanUpdateManyWithoutProgresTahapanNestedInput
  }

  export type ProgresTahapanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksiId?: IntFieldUpdateOperationsInput | number
    tahapanId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dokumen?: DokumenProgresTahapanUncheckedUpdateManyWithoutProgresTahapanNestedInput
  }

  export type ProgresTahapanCreateManyInput = {
    id?: number
    transaksiId: number
    tahapanId: number
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
  }

  export type ProgresTahapanUpdateManyMutationInput = {
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresTahapanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksiId?: IntFieldUpdateOperationsInput | number
    tahapanId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgresTahapanCreateInput = {
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
    progresTahapan: ProgresTahapanCreateNestedOneWithoutDokumenInput
  }

  export type DokumenProgresTahapanUncheckedCreateInput = {
    id?: number
    progresTahapanId: number
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgresTahapanUpdateInput = {
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progresTahapan?: ProgresTahapanUpdateOneRequiredWithoutDokumenNestedInput
  }

  export type DokumenProgresTahapanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    progresTahapanId?: IntFieldUpdateOperationsInput | number
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgresTahapanCreateManyInput = {
    id?: number
    progresTahapanId: number
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgresTahapanUpdateManyMutationInput = {
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgresTahapanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    progresTahapanId?: IntFieldUpdateOperationsInput | number
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DinasNullableRelationFilter = {
    is?: DinasWhereInput | null
    isNot?: DinasWhereInput | null
  }

  export type AccessTokenListRelationFilter = {
    every?: AccessTokenWhereInput
    some?: AccessTokenWhereInput
    none?: AccessTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccessTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    dinasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    dinasId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    dinasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    dinasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    dinasId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccessTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AccessTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DinasCountOrderByAggregateInput = {
    id?: SortOrder
    namaDinas?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DinasAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DinasMaxOrderByAggregateInput = {
    id?: SortOrder
    namaDinas?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DinasMinOrderByAggregateInput = {
    id?: SortOrder
    namaDinas?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DinasSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type DinasRelationFilter = {
    is?: DinasWhereInput
    isNot?: DinasWhereInput
  }

  export type TransaksiPengadaanListRelationFilter = {
    every?: TransaksiPengadaanWhereInput
    some?: TransaksiPengadaanWhereInput
    none?: TransaksiPengadaanWhereInput
  }

  export type DokumenProgramListRelationFilter = {
    every?: DokumenProgramWhereInput
    some?: DokumenProgramWhereInput
    none?: DokumenProgramWhereInput
  }

  export type TransaksiPengadaanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DokumenProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    namaProgram?: SortOrder
    slug?: SortOrder
    anggaran?: SortOrder
    isPrioritas?: SortOrder
    dinasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    anggaran?: SortOrder
    dinasId?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    namaProgram?: SortOrder
    slug?: SortOrder
    anggaran?: SortOrder
    isPrioritas?: SortOrder
    dinasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    namaProgram?: SortOrder
    slug?: SortOrder
    anggaran?: SortOrder
    isPrioritas?: SortOrder
    dinasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    id?: SortOrder
    anggaran?: SortOrder
    dinasId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type ProgramRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type DokumenProgramCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DokumenProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
  }

  export type DokumenProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DokumenProgramMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DokumenProgramSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
  }

  export type TahapanListRelationFilter = {
    every?: TahapanWhereInput
    some?: TahapanWhereInput
    none?: TahapanWhereInput
  }

  export type TahapanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PengadaanCountOrderByAggregateInput = {
    id?: SortOrder
    namaPengadaan?: SortOrder
  }

  export type PengadaanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PengadaanMaxOrderByAggregateInput = {
    id?: SortOrder
    namaPengadaan?: SortOrder
  }

  export type PengadaanMinOrderByAggregateInput = {
    id?: SortOrder
    namaPengadaan?: SortOrder
  }

  export type PengadaanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PengadaanRelationFilter = {
    is?: PengadaanWhereInput
    isNot?: PengadaanWhereInput
  }

  export type ProgresTahapanListRelationFilter = {
    every?: ProgresTahapanWhereInput
    some?: ProgresTahapanWhereInput
    none?: ProgresTahapanWhereInput
  }

  export type ProgresTahapanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TahapanCountOrderByAggregateInput = {
    id?: SortOrder
    pengadaanId?: SortOrder
    noUrut?: SortOrder
    namaTahapan?: SortOrder
    standarWaktuHari?: SortOrder
    isWaktuEditable?: SortOrder
    bobot?: SortOrder
  }

  export type TahapanAvgOrderByAggregateInput = {
    id?: SortOrder
    pengadaanId?: SortOrder
    noUrut?: SortOrder
    standarWaktuHari?: SortOrder
    bobot?: SortOrder
  }

  export type TahapanMaxOrderByAggregateInput = {
    id?: SortOrder
    pengadaanId?: SortOrder
    noUrut?: SortOrder
    namaTahapan?: SortOrder
    standarWaktuHari?: SortOrder
    isWaktuEditable?: SortOrder
    bobot?: SortOrder
  }

  export type TahapanMinOrderByAggregateInput = {
    id?: SortOrder
    pengadaanId?: SortOrder
    noUrut?: SortOrder
    namaTahapan?: SortOrder
    standarWaktuHari?: SortOrder
    isWaktuEditable?: SortOrder
    bobot?: SortOrder
  }

  export type TahapanSumOrderByAggregateInput = {
    id?: SortOrder
    pengadaanId?: SortOrder
    noUrut?: SortOrder
    standarWaktuHari?: SortOrder
    bobot?: SortOrder
  }

  export type TransaksiPengadaanCountOrderByAggregateInput = {
    id?: SortOrder
    namaTransaksi?: SortOrder
    title?: SortOrder
    programId?: SortOrder
    pengadaanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransaksiPengadaanAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    pengadaanId?: SortOrder
  }

  export type TransaksiPengadaanMaxOrderByAggregateInput = {
    id?: SortOrder
    namaTransaksi?: SortOrder
    title?: SortOrder
    programId?: SortOrder
    pengadaanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransaksiPengadaanMinOrderByAggregateInput = {
    id?: SortOrder
    namaTransaksi?: SortOrder
    title?: SortOrder
    programId?: SortOrder
    pengadaanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransaksiPengadaanSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    pengadaanId?: SortOrder
  }

  export type EnumStatusTahapanFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusTahapan | EnumStatusTahapanFieldRefInput<$PrismaModel>
    in?: $Enums.StatusTahapan[]
    notIn?: $Enums.StatusTahapan[]
    not?: NestedEnumStatusTahapanFilter<$PrismaModel> | $Enums.StatusTahapan
  }

  export type TransaksiPengadaanRelationFilter = {
    is?: TransaksiPengadaanWhereInput
    isNot?: TransaksiPengadaanWhereInput
  }

  export type TahapanRelationFilter = {
    is?: TahapanWhereInput
    isNot?: TahapanWhereInput
  }

  export type DokumenProgresTahapanListRelationFilter = {
    every?: DokumenProgresTahapanWhereInput
    some?: DokumenProgresTahapanWhereInput
    none?: DokumenProgresTahapanWhereInput
  }

  export type DokumenProgresTahapanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgresTahapanTransaksiIdTahapanIdCompoundUniqueInput = {
    transaksiId: number
    tahapanId: number
  }

  export type ProgresTahapanCountOrderByAggregateInput = {
    id?: SortOrder
    transaksiId?: SortOrder
    tahapanId?: SortOrder
    status?: SortOrder
    planningTanggalMulai?: SortOrder
    planningTanggalSelesai?: SortOrder
    aktualTanggalMulai?: SortOrder
    aktualTanggalSelesai?: SortOrder
    keterangan?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgresTahapanAvgOrderByAggregateInput = {
    id?: SortOrder
    transaksiId?: SortOrder
    tahapanId?: SortOrder
  }

  export type ProgresTahapanMaxOrderByAggregateInput = {
    id?: SortOrder
    transaksiId?: SortOrder
    tahapanId?: SortOrder
    status?: SortOrder
    planningTanggalMulai?: SortOrder
    planningTanggalSelesai?: SortOrder
    aktualTanggalMulai?: SortOrder
    aktualTanggalSelesai?: SortOrder
    keterangan?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgresTahapanMinOrderByAggregateInput = {
    id?: SortOrder
    transaksiId?: SortOrder
    tahapanId?: SortOrder
    status?: SortOrder
    planningTanggalMulai?: SortOrder
    planningTanggalSelesai?: SortOrder
    aktualTanggalMulai?: SortOrder
    aktualTanggalSelesai?: SortOrder
    keterangan?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgresTahapanSumOrderByAggregateInput = {
    id?: SortOrder
    transaksiId?: SortOrder
    tahapanId?: SortOrder
  }

  export type EnumStatusTahapanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusTahapan | EnumStatusTahapanFieldRefInput<$PrismaModel>
    in?: $Enums.StatusTahapan[]
    notIn?: $Enums.StatusTahapan[]
    not?: NestedEnumStatusTahapanWithAggregatesFilter<$PrismaModel> | $Enums.StatusTahapan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTahapanFilter<$PrismaModel>
    _max?: NestedEnumStatusTahapanFilter<$PrismaModel>
  }

  export type ProgresTahapanRelationFilter = {
    is?: ProgresTahapanWhereInput
    isNot?: ProgresTahapanWhereInput
  }

  export type DokumenProgresTahapanCountOrderByAggregateInput = {
    id?: SortOrder
    progresTahapanId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DokumenProgresTahapanAvgOrderByAggregateInput = {
    id?: SortOrder
    progresTahapanId?: SortOrder
  }

  export type DokumenProgresTahapanMaxOrderByAggregateInput = {
    id?: SortOrder
    progresTahapanId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DokumenProgresTahapanMinOrderByAggregateInput = {
    id?: SortOrder
    progresTahapanId?: SortOrder
    namaFile?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DokumenProgresTahapanSumOrderByAggregateInput = {
    id?: SortOrder
    progresTahapanId?: SortOrder
  }

  export type DinasCreateNestedOneWithoutUsersInput = {
    create?: XOR<DinasCreateWithoutUsersInput, DinasUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DinasCreateOrConnectWithoutUsersInput
    connect?: DinasWhereUniqueInput
  }

  export type AccessTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
  }

  export type AccessTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DinasUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DinasCreateWithoutUsersInput, DinasUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DinasCreateOrConnectWithoutUsersInput
    upsert?: DinasUpsertWithoutUsersInput
    disconnect?: DinasWhereInput | boolean
    delete?: DinasWhereInput | boolean
    connect?: DinasWhereUniqueInput
    update?: XOR<XOR<DinasUpdateToOneWithWhereWithoutUsersInput, DinasUpdateWithoutUsersInput>, DinasUncheckedUpdateWithoutUsersInput>
  }

  export type AccessTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    upsert?: AccessTokenUpsertWithWhereUniqueWithoutUserInput | AccessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    set?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    disconnect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    delete?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    update?: AccessTokenUpdateWithWhereUniqueWithoutUserInput | AccessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccessTokenUpdateManyWithWhereWithoutUserInput | AccessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccessTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    upsert?: AccessTokenUpsertWithWhereUniqueWithoutUserInput | AccessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    set?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    disconnect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    delete?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    update?: AccessTokenUpdateWithWhereUniqueWithoutUserInput | AccessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccessTokenUpdateManyWithWhereWithoutUserInput | AccessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccessTokensInput = {
    create?: XOR<UserCreateWithoutAccessTokensInput, UserUncheckedCreateWithoutAccessTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessTokensInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutAccessTokensNestedInput = {
    create?: XOR<UserCreateWithoutAccessTokensInput, UserUncheckedCreateWithoutAccessTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessTokensInput
    upsert?: UserUpsertWithoutAccessTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccessTokensInput, UserUpdateWithoutAccessTokensInput>, UserUncheckedUpdateWithoutAccessTokensInput>
  }

  export type UserCreateNestedManyWithoutDinasInput = {
    create?: XOR<UserCreateWithoutDinasInput, UserUncheckedCreateWithoutDinasInput> | UserCreateWithoutDinasInput[] | UserUncheckedCreateWithoutDinasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDinasInput | UserCreateOrConnectWithoutDinasInput[]
    createMany?: UserCreateManyDinasInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProgramCreateNestedManyWithoutDinasInput = {
    create?: XOR<ProgramCreateWithoutDinasInput, ProgramUncheckedCreateWithoutDinasInput> | ProgramCreateWithoutDinasInput[] | ProgramUncheckedCreateWithoutDinasInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutDinasInput | ProgramCreateOrConnectWithoutDinasInput[]
    createMany?: ProgramCreateManyDinasInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDinasInput = {
    create?: XOR<UserCreateWithoutDinasInput, UserUncheckedCreateWithoutDinasInput> | UserCreateWithoutDinasInput[] | UserUncheckedCreateWithoutDinasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDinasInput | UserCreateOrConnectWithoutDinasInput[]
    createMany?: UserCreateManyDinasInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutDinasInput = {
    create?: XOR<ProgramCreateWithoutDinasInput, ProgramUncheckedCreateWithoutDinasInput> | ProgramCreateWithoutDinasInput[] | ProgramUncheckedCreateWithoutDinasInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutDinasInput | ProgramCreateOrConnectWithoutDinasInput[]
    createMany?: ProgramCreateManyDinasInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutDinasNestedInput = {
    create?: XOR<UserCreateWithoutDinasInput, UserUncheckedCreateWithoutDinasInput> | UserCreateWithoutDinasInput[] | UserUncheckedCreateWithoutDinasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDinasInput | UserCreateOrConnectWithoutDinasInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDinasInput | UserUpsertWithWhereUniqueWithoutDinasInput[]
    createMany?: UserCreateManyDinasInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDinasInput | UserUpdateWithWhereUniqueWithoutDinasInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDinasInput | UserUpdateManyWithWhereWithoutDinasInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProgramUpdateManyWithoutDinasNestedInput = {
    create?: XOR<ProgramCreateWithoutDinasInput, ProgramUncheckedCreateWithoutDinasInput> | ProgramCreateWithoutDinasInput[] | ProgramUncheckedCreateWithoutDinasInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutDinasInput | ProgramCreateOrConnectWithoutDinasInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutDinasInput | ProgramUpsertWithWhereUniqueWithoutDinasInput[]
    createMany?: ProgramCreateManyDinasInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutDinasInput | ProgramUpdateWithWhereUniqueWithoutDinasInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutDinasInput | ProgramUpdateManyWithWhereWithoutDinasInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDinasNestedInput = {
    create?: XOR<UserCreateWithoutDinasInput, UserUncheckedCreateWithoutDinasInput> | UserCreateWithoutDinasInput[] | UserUncheckedCreateWithoutDinasInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDinasInput | UserCreateOrConnectWithoutDinasInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDinasInput | UserUpsertWithWhereUniqueWithoutDinasInput[]
    createMany?: UserCreateManyDinasInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDinasInput | UserUpdateWithWhereUniqueWithoutDinasInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDinasInput | UserUpdateManyWithWhereWithoutDinasInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutDinasNestedInput = {
    create?: XOR<ProgramCreateWithoutDinasInput, ProgramUncheckedCreateWithoutDinasInput> | ProgramCreateWithoutDinasInput[] | ProgramUncheckedCreateWithoutDinasInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutDinasInput | ProgramCreateOrConnectWithoutDinasInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutDinasInput | ProgramUpsertWithWhereUniqueWithoutDinasInput[]
    createMany?: ProgramCreateManyDinasInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutDinasInput | ProgramUpdateWithWhereUniqueWithoutDinasInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutDinasInput | ProgramUpdateManyWithWhereWithoutDinasInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type DinasCreateNestedOneWithoutProgramsInput = {
    create?: XOR<DinasCreateWithoutProgramsInput, DinasUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: DinasCreateOrConnectWithoutProgramsInput
    connect?: DinasWhereUniqueInput
  }

  export type TransaksiPengadaanCreateNestedManyWithoutProgramInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutProgramInput, TransaksiPengadaanUncheckedCreateWithoutProgramInput> | TransaksiPengadaanCreateWithoutProgramInput[] | TransaksiPengadaanUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutProgramInput | TransaksiPengadaanCreateOrConnectWithoutProgramInput[]
    createMany?: TransaksiPengadaanCreateManyProgramInputEnvelope
    connect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
  }

  export type DokumenProgramCreateNestedManyWithoutProgramInput = {
    create?: XOR<DokumenProgramCreateWithoutProgramInput, DokumenProgramUncheckedCreateWithoutProgramInput> | DokumenProgramCreateWithoutProgramInput[] | DokumenProgramUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: DokumenProgramCreateOrConnectWithoutProgramInput | DokumenProgramCreateOrConnectWithoutProgramInput[]
    createMany?: DokumenProgramCreateManyProgramInputEnvelope
    connect?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
  }

  export type TransaksiPengadaanUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutProgramInput, TransaksiPengadaanUncheckedCreateWithoutProgramInput> | TransaksiPengadaanCreateWithoutProgramInput[] | TransaksiPengadaanUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutProgramInput | TransaksiPengadaanCreateOrConnectWithoutProgramInput[]
    createMany?: TransaksiPengadaanCreateManyProgramInputEnvelope
    connect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
  }

  export type DokumenProgramUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<DokumenProgramCreateWithoutProgramInput, DokumenProgramUncheckedCreateWithoutProgramInput> | DokumenProgramCreateWithoutProgramInput[] | DokumenProgramUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: DokumenProgramCreateOrConnectWithoutProgramInput | DokumenProgramCreateOrConnectWithoutProgramInput[]
    createMany?: DokumenProgramCreateManyProgramInputEnvelope
    connect?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DinasUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<DinasCreateWithoutProgramsInput, DinasUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: DinasCreateOrConnectWithoutProgramsInput
    upsert?: DinasUpsertWithoutProgramsInput
    connect?: DinasWhereUniqueInput
    update?: XOR<XOR<DinasUpdateToOneWithWhereWithoutProgramsInput, DinasUpdateWithoutProgramsInput>, DinasUncheckedUpdateWithoutProgramsInput>
  }

  export type TransaksiPengadaanUpdateManyWithoutProgramNestedInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutProgramInput, TransaksiPengadaanUncheckedCreateWithoutProgramInput> | TransaksiPengadaanCreateWithoutProgramInput[] | TransaksiPengadaanUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutProgramInput | TransaksiPengadaanCreateOrConnectWithoutProgramInput[]
    upsert?: TransaksiPengadaanUpsertWithWhereUniqueWithoutProgramInput | TransaksiPengadaanUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: TransaksiPengadaanCreateManyProgramInputEnvelope
    set?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    disconnect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    delete?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    connect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    update?: TransaksiPengadaanUpdateWithWhereUniqueWithoutProgramInput | TransaksiPengadaanUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: TransaksiPengadaanUpdateManyWithWhereWithoutProgramInput | TransaksiPengadaanUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: TransaksiPengadaanScalarWhereInput | TransaksiPengadaanScalarWhereInput[]
  }

  export type DokumenProgramUpdateManyWithoutProgramNestedInput = {
    create?: XOR<DokumenProgramCreateWithoutProgramInput, DokumenProgramUncheckedCreateWithoutProgramInput> | DokumenProgramCreateWithoutProgramInput[] | DokumenProgramUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: DokumenProgramCreateOrConnectWithoutProgramInput | DokumenProgramCreateOrConnectWithoutProgramInput[]
    upsert?: DokumenProgramUpsertWithWhereUniqueWithoutProgramInput | DokumenProgramUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: DokumenProgramCreateManyProgramInputEnvelope
    set?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
    disconnect?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
    delete?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
    connect?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
    update?: DokumenProgramUpdateWithWhereUniqueWithoutProgramInput | DokumenProgramUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: DokumenProgramUpdateManyWithWhereWithoutProgramInput | DokumenProgramUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: DokumenProgramScalarWhereInput | DokumenProgramScalarWhereInput[]
  }

  export type TransaksiPengadaanUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutProgramInput, TransaksiPengadaanUncheckedCreateWithoutProgramInput> | TransaksiPengadaanCreateWithoutProgramInput[] | TransaksiPengadaanUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutProgramInput | TransaksiPengadaanCreateOrConnectWithoutProgramInput[]
    upsert?: TransaksiPengadaanUpsertWithWhereUniqueWithoutProgramInput | TransaksiPengadaanUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: TransaksiPengadaanCreateManyProgramInputEnvelope
    set?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    disconnect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    delete?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    connect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    update?: TransaksiPengadaanUpdateWithWhereUniqueWithoutProgramInput | TransaksiPengadaanUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: TransaksiPengadaanUpdateManyWithWhereWithoutProgramInput | TransaksiPengadaanUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: TransaksiPengadaanScalarWhereInput | TransaksiPengadaanScalarWhereInput[]
  }

  export type DokumenProgramUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<DokumenProgramCreateWithoutProgramInput, DokumenProgramUncheckedCreateWithoutProgramInput> | DokumenProgramCreateWithoutProgramInput[] | DokumenProgramUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: DokumenProgramCreateOrConnectWithoutProgramInput | DokumenProgramCreateOrConnectWithoutProgramInput[]
    upsert?: DokumenProgramUpsertWithWhereUniqueWithoutProgramInput | DokumenProgramUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: DokumenProgramCreateManyProgramInputEnvelope
    set?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
    disconnect?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
    delete?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
    connect?: DokumenProgramWhereUniqueInput | DokumenProgramWhereUniqueInput[]
    update?: DokumenProgramUpdateWithWhereUniqueWithoutProgramInput | DokumenProgramUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: DokumenProgramUpdateManyWithWhereWithoutProgramInput | DokumenProgramUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: DokumenProgramScalarWhereInput | DokumenProgramScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutDokumenInput = {
    create?: XOR<ProgramCreateWithoutDokumenInput, ProgramUncheckedCreateWithoutDokumenInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutDokumenInput
    connect?: ProgramWhereUniqueInput
  }

  export type ProgramUpdateOneRequiredWithoutDokumenNestedInput = {
    create?: XOR<ProgramCreateWithoutDokumenInput, ProgramUncheckedCreateWithoutDokumenInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutDokumenInput
    upsert?: ProgramUpsertWithoutDokumenInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutDokumenInput, ProgramUpdateWithoutDokumenInput>, ProgramUncheckedUpdateWithoutDokumenInput>
  }

  export type TahapanCreateNestedManyWithoutPengadaanInput = {
    create?: XOR<TahapanCreateWithoutPengadaanInput, TahapanUncheckedCreateWithoutPengadaanInput> | TahapanCreateWithoutPengadaanInput[] | TahapanUncheckedCreateWithoutPengadaanInput[]
    connectOrCreate?: TahapanCreateOrConnectWithoutPengadaanInput | TahapanCreateOrConnectWithoutPengadaanInput[]
    createMany?: TahapanCreateManyPengadaanInputEnvelope
    connect?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
  }

  export type TransaksiPengadaanCreateNestedManyWithoutPengadaanInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutPengadaanInput, TransaksiPengadaanUncheckedCreateWithoutPengadaanInput> | TransaksiPengadaanCreateWithoutPengadaanInput[] | TransaksiPengadaanUncheckedCreateWithoutPengadaanInput[]
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutPengadaanInput | TransaksiPengadaanCreateOrConnectWithoutPengadaanInput[]
    createMany?: TransaksiPengadaanCreateManyPengadaanInputEnvelope
    connect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
  }

  export type TahapanUncheckedCreateNestedManyWithoutPengadaanInput = {
    create?: XOR<TahapanCreateWithoutPengadaanInput, TahapanUncheckedCreateWithoutPengadaanInput> | TahapanCreateWithoutPengadaanInput[] | TahapanUncheckedCreateWithoutPengadaanInput[]
    connectOrCreate?: TahapanCreateOrConnectWithoutPengadaanInput | TahapanCreateOrConnectWithoutPengadaanInput[]
    createMany?: TahapanCreateManyPengadaanInputEnvelope
    connect?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
  }

  export type TransaksiPengadaanUncheckedCreateNestedManyWithoutPengadaanInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutPengadaanInput, TransaksiPengadaanUncheckedCreateWithoutPengadaanInput> | TransaksiPengadaanCreateWithoutPengadaanInput[] | TransaksiPengadaanUncheckedCreateWithoutPengadaanInput[]
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutPengadaanInput | TransaksiPengadaanCreateOrConnectWithoutPengadaanInput[]
    createMany?: TransaksiPengadaanCreateManyPengadaanInputEnvelope
    connect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
  }

  export type TahapanUpdateManyWithoutPengadaanNestedInput = {
    create?: XOR<TahapanCreateWithoutPengadaanInput, TahapanUncheckedCreateWithoutPengadaanInput> | TahapanCreateWithoutPengadaanInput[] | TahapanUncheckedCreateWithoutPengadaanInput[]
    connectOrCreate?: TahapanCreateOrConnectWithoutPengadaanInput | TahapanCreateOrConnectWithoutPengadaanInput[]
    upsert?: TahapanUpsertWithWhereUniqueWithoutPengadaanInput | TahapanUpsertWithWhereUniqueWithoutPengadaanInput[]
    createMany?: TahapanCreateManyPengadaanInputEnvelope
    set?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
    disconnect?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
    delete?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
    connect?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
    update?: TahapanUpdateWithWhereUniqueWithoutPengadaanInput | TahapanUpdateWithWhereUniqueWithoutPengadaanInput[]
    updateMany?: TahapanUpdateManyWithWhereWithoutPengadaanInput | TahapanUpdateManyWithWhereWithoutPengadaanInput[]
    deleteMany?: TahapanScalarWhereInput | TahapanScalarWhereInput[]
  }

  export type TransaksiPengadaanUpdateManyWithoutPengadaanNestedInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutPengadaanInput, TransaksiPengadaanUncheckedCreateWithoutPengadaanInput> | TransaksiPengadaanCreateWithoutPengadaanInput[] | TransaksiPengadaanUncheckedCreateWithoutPengadaanInput[]
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutPengadaanInput | TransaksiPengadaanCreateOrConnectWithoutPengadaanInput[]
    upsert?: TransaksiPengadaanUpsertWithWhereUniqueWithoutPengadaanInput | TransaksiPengadaanUpsertWithWhereUniqueWithoutPengadaanInput[]
    createMany?: TransaksiPengadaanCreateManyPengadaanInputEnvelope
    set?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    disconnect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    delete?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    connect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    update?: TransaksiPengadaanUpdateWithWhereUniqueWithoutPengadaanInput | TransaksiPengadaanUpdateWithWhereUniqueWithoutPengadaanInput[]
    updateMany?: TransaksiPengadaanUpdateManyWithWhereWithoutPengadaanInput | TransaksiPengadaanUpdateManyWithWhereWithoutPengadaanInput[]
    deleteMany?: TransaksiPengadaanScalarWhereInput | TransaksiPengadaanScalarWhereInput[]
  }

  export type TahapanUncheckedUpdateManyWithoutPengadaanNestedInput = {
    create?: XOR<TahapanCreateWithoutPengadaanInput, TahapanUncheckedCreateWithoutPengadaanInput> | TahapanCreateWithoutPengadaanInput[] | TahapanUncheckedCreateWithoutPengadaanInput[]
    connectOrCreate?: TahapanCreateOrConnectWithoutPengadaanInput | TahapanCreateOrConnectWithoutPengadaanInput[]
    upsert?: TahapanUpsertWithWhereUniqueWithoutPengadaanInput | TahapanUpsertWithWhereUniqueWithoutPengadaanInput[]
    createMany?: TahapanCreateManyPengadaanInputEnvelope
    set?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
    disconnect?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
    delete?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
    connect?: TahapanWhereUniqueInput | TahapanWhereUniqueInput[]
    update?: TahapanUpdateWithWhereUniqueWithoutPengadaanInput | TahapanUpdateWithWhereUniqueWithoutPengadaanInput[]
    updateMany?: TahapanUpdateManyWithWhereWithoutPengadaanInput | TahapanUpdateManyWithWhereWithoutPengadaanInput[]
    deleteMany?: TahapanScalarWhereInput | TahapanScalarWhereInput[]
  }

  export type TransaksiPengadaanUncheckedUpdateManyWithoutPengadaanNestedInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutPengadaanInput, TransaksiPengadaanUncheckedCreateWithoutPengadaanInput> | TransaksiPengadaanCreateWithoutPengadaanInput[] | TransaksiPengadaanUncheckedCreateWithoutPengadaanInput[]
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutPengadaanInput | TransaksiPengadaanCreateOrConnectWithoutPengadaanInput[]
    upsert?: TransaksiPengadaanUpsertWithWhereUniqueWithoutPengadaanInput | TransaksiPengadaanUpsertWithWhereUniqueWithoutPengadaanInput[]
    createMany?: TransaksiPengadaanCreateManyPengadaanInputEnvelope
    set?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    disconnect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    delete?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    connect?: TransaksiPengadaanWhereUniqueInput | TransaksiPengadaanWhereUniqueInput[]
    update?: TransaksiPengadaanUpdateWithWhereUniqueWithoutPengadaanInput | TransaksiPengadaanUpdateWithWhereUniqueWithoutPengadaanInput[]
    updateMany?: TransaksiPengadaanUpdateManyWithWhereWithoutPengadaanInput | TransaksiPengadaanUpdateManyWithWhereWithoutPengadaanInput[]
    deleteMany?: TransaksiPengadaanScalarWhereInput | TransaksiPengadaanScalarWhereInput[]
  }

  export type PengadaanCreateNestedOneWithoutTahapanInput = {
    create?: XOR<PengadaanCreateWithoutTahapanInput, PengadaanUncheckedCreateWithoutTahapanInput>
    connectOrCreate?: PengadaanCreateOrConnectWithoutTahapanInput
    connect?: PengadaanWhereUniqueInput
  }

  export type ProgresTahapanCreateNestedManyWithoutTahapanInput = {
    create?: XOR<ProgresTahapanCreateWithoutTahapanInput, ProgresTahapanUncheckedCreateWithoutTahapanInput> | ProgresTahapanCreateWithoutTahapanInput[] | ProgresTahapanUncheckedCreateWithoutTahapanInput[]
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutTahapanInput | ProgresTahapanCreateOrConnectWithoutTahapanInput[]
    createMany?: ProgresTahapanCreateManyTahapanInputEnvelope
    connect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
  }

  export type ProgresTahapanUncheckedCreateNestedManyWithoutTahapanInput = {
    create?: XOR<ProgresTahapanCreateWithoutTahapanInput, ProgresTahapanUncheckedCreateWithoutTahapanInput> | ProgresTahapanCreateWithoutTahapanInput[] | ProgresTahapanUncheckedCreateWithoutTahapanInput[]
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutTahapanInput | ProgresTahapanCreateOrConnectWithoutTahapanInput[]
    createMany?: ProgresTahapanCreateManyTahapanInputEnvelope
    connect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
  }

  export type PengadaanUpdateOneRequiredWithoutTahapanNestedInput = {
    create?: XOR<PengadaanCreateWithoutTahapanInput, PengadaanUncheckedCreateWithoutTahapanInput>
    connectOrCreate?: PengadaanCreateOrConnectWithoutTahapanInput
    upsert?: PengadaanUpsertWithoutTahapanInput
    connect?: PengadaanWhereUniqueInput
    update?: XOR<XOR<PengadaanUpdateToOneWithWhereWithoutTahapanInput, PengadaanUpdateWithoutTahapanInput>, PengadaanUncheckedUpdateWithoutTahapanInput>
  }

  export type ProgresTahapanUpdateManyWithoutTahapanNestedInput = {
    create?: XOR<ProgresTahapanCreateWithoutTahapanInput, ProgresTahapanUncheckedCreateWithoutTahapanInput> | ProgresTahapanCreateWithoutTahapanInput[] | ProgresTahapanUncheckedCreateWithoutTahapanInput[]
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutTahapanInput | ProgresTahapanCreateOrConnectWithoutTahapanInput[]
    upsert?: ProgresTahapanUpsertWithWhereUniqueWithoutTahapanInput | ProgresTahapanUpsertWithWhereUniqueWithoutTahapanInput[]
    createMany?: ProgresTahapanCreateManyTahapanInputEnvelope
    set?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    disconnect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    delete?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    connect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    update?: ProgresTahapanUpdateWithWhereUniqueWithoutTahapanInput | ProgresTahapanUpdateWithWhereUniqueWithoutTahapanInput[]
    updateMany?: ProgresTahapanUpdateManyWithWhereWithoutTahapanInput | ProgresTahapanUpdateManyWithWhereWithoutTahapanInput[]
    deleteMany?: ProgresTahapanScalarWhereInput | ProgresTahapanScalarWhereInput[]
  }

  export type ProgresTahapanUncheckedUpdateManyWithoutTahapanNestedInput = {
    create?: XOR<ProgresTahapanCreateWithoutTahapanInput, ProgresTahapanUncheckedCreateWithoutTahapanInput> | ProgresTahapanCreateWithoutTahapanInput[] | ProgresTahapanUncheckedCreateWithoutTahapanInput[]
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutTahapanInput | ProgresTahapanCreateOrConnectWithoutTahapanInput[]
    upsert?: ProgresTahapanUpsertWithWhereUniqueWithoutTahapanInput | ProgresTahapanUpsertWithWhereUniqueWithoutTahapanInput[]
    createMany?: ProgresTahapanCreateManyTahapanInputEnvelope
    set?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    disconnect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    delete?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    connect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    update?: ProgresTahapanUpdateWithWhereUniqueWithoutTahapanInput | ProgresTahapanUpdateWithWhereUniqueWithoutTahapanInput[]
    updateMany?: ProgresTahapanUpdateManyWithWhereWithoutTahapanInput | ProgresTahapanUpdateManyWithWhereWithoutTahapanInput[]
    deleteMany?: ProgresTahapanScalarWhereInput | ProgresTahapanScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutPengadaanInput = {
    create?: XOR<ProgramCreateWithoutPengadaanInput, ProgramUncheckedCreateWithoutPengadaanInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutPengadaanInput
    connect?: ProgramWhereUniqueInput
  }

  export type PengadaanCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<PengadaanCreateWithoutTransaksiInput, PengadaanUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: PengadaanCreateOrConnectWithoutTransaksiInput
    connect?: PengadaanWhereUniqueInput
  }

  export type ProgresTahapanCreateNestedManyWithoutTransaksiInput = {
    create?: XOR<ProgresTahapanCreateWithoutTransaksiInput, ProgresTahapanUncheckedCreateWithoutTransaksiInput> | ProgresTahapanCreateWithoutTransaksiInput[] | ProgresTahapanUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutTransaksiInput | ProgresTahapanCreateOrConnectWithoutTransaksiInput[]
    createMany?: ProgresTahapanCreateManyTransaksiInputEnvelope
    connect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
  }

  export type ProgresTahapanUncheckedCreateNestedManyWithoutTransaksiInput = {
    create?: XOR<ProgresTahapanCreateWithoutTransaksiInput, ProgresTahapanUncheckedCreateWithoutTransaksiInput> | ProgresTahapanCreateWithoutTransaksiInput[] | ProgresTahapanUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutTransaksiInput | ProgresTahapanCreateOrConnectWithoutTransaksiInput[]
    createMany?: ProgresTahapanCreateManyTransaksiInputEnvelope
    connect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
  }

  export type ProgramUpdateOneRequiredWithoutPengadaanNestedInput = {
    create?: XOR<ProgramCreateWithoutPengadaanInput, ProgramUncheckedCreateWithoutPengadaanInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutPengadaanInput
    upsert?: ProgramUpsertWithoutPengadaanInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutPengadaanInput, ProgramUpdateWithoutPengadaanInput>, ProgramUncheckedUpdateWithoutPengadaanInput>
  }

  export type PengadaanUpdateOneRequiredWithoutTransaksiNestedInput = {
    create?: XOR<PengadaanCreateWithoutTransaksiInput, PengadaanUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: PengadaanCreateOrConnectWithoutTransaksiInput
    upsert?: PengadaanUpsertWithoutTransaksiInput
    connect?: PengadaanWhereUniqueInput
    update?: XOR<XOR<PengadaanUpdateToOneWithWhereWithoutTransaksiInput, PengadaanUpdateWithoutTransaksiInput>, PengadaanUncheckedUpdateWithoutTransaksiInput>
  }

  export type ProgresTahapanUpdateManyWithoutTransaksiNestedInput = {
    create?: XOR<ProgresTahapanCreateWithoutTransaksiInput, ProgresTahapanUncheckedCreateWithoutTransaksiInput> | ProgresTahapanCreateWithoutTransaksiInput[] | ProgresTahapanUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutTransaksiInput | ProgresTahapanCreateOrConnectWithoutTransaksiInput[]
    upsert?: ProgresTahapanUpsertWithWhereUniqueWithoutTransaksiInput | ProgresTahapanUpsertWithWhereUniqueWithoutTransaksiInput[]
    createMany?: ProgresTahapanCreateManyTransaksiInputEnvelope
    set?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    disconnect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    delete?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    connect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    update?: ProgresTahapanUpdateWithWhereUniqueWithoutTransaksiInput | ProgresTahapanUpdateWithWhereUniqueWithoutTransaksiInput[]
    updateMany?: ProgresTahapanUpdateManyWithWhereWithoutTransaksiInput | ProgresTahapanUpdateManyWithWhereWithoutTransaksiInput[]
    deleteMany?: ProgresTahapanScalarWhereInput | ProgresTahapanScalarWhereInput[]
  }

  export type ProgresTahapanUncheckedUpdateManyWithoutTransaksiNestedInput = {
    create?: XOR<ProgresTahapanCreateWithoutTransaksiInput, ProgresTahapanUncheckedCreateWithoutTransaksiInput> | ProgresTahapanCreateWithoutTransaksiInput[] | ProgresTahapanUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutTransaksiInput | ProgresTahapanCreateOrConnectWithoutTransaksiInput[]
    upsert?: ProgresTahapanUpsertWithWhereUniqueWithoutTransaksiInput | ProgresTahapanUpsertWithWhereUniqueWithoutTransaksiInput[]
    createMany?: ProgresTahapanCreateManyTransaksiInputEnvelope
    set?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    disconnect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    delete?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    connect?: ProgresTahapanWhereUniqueInput | ProgresTahapanWhereUniqueInput[]
    update?: ProgresTahapanUpdateWithWhereUniqueWithoutTransaksiInput | ProgresTahapanUpdateWithWhereUniqueWithoutTransaksiInput[]
    updateMany?: ProgresTahapanUpdateManyWithWhereWithoutTransaksiInput | ProgresTahapanUpdateManyWithWhereWithoutTransaksiInput[]
    deleteMany?: ProgresTahapanScalarWhereInput | ProgresTahapanScalarWhereInput[]
  }

  export type TransaksiPengadaanCreateNestedOneWithoutProgresTahapanInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutProgresTahapanInput, TransaksiPengadaanUncheckedCreateWithoutProgresTahapanInput>
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutProgresTahapanInput
    connect?: TransaksiPengadaanWhereUniqueInput
  }

  export type TahapanCreateNestedOneWithoutProgresTahapanInput = {
    create?: XOR<TahapanCreateWithoutProgresTahapanInput, TahapanUncheckedCreateWithoutProgresTahapanInput>
    connectOrCreate?: TahapanCreateOrConnectWithoutProgresTahapanInput
    connect?: TahapanWhereUniqueInput
  }

  export type DokumenProgresTahapanCreateNestedManyWithoutProgresTahapanInput = {
    create?: XOR<DokumenProgresTahapanCreateWithoutProgresTahapanInput, DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput> | DokumenProgresTahapanCreateWithoutProgresTahapanInput[] | DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput[]
    connectOrCreate?: DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput | DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput[]
    createMany?: DokumenProgresTahapanCreateManyProgresTahapanInputEnvelope
    connect?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
  }

  export type DokumenProgresTahapanUncheckedCreateNestedManyWithoutProgresTahapanInput = {
    create?: XOR<DokumenProgresTahapanCreateWithoutProgresTahapanInput, DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput> | DokumenProgresTahapanCreateWithoutProgresTahapanInput[] | DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput[]
    connectOrCreate?: DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput | DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput[]
    createMany?: DokumenProgresTahapanCreateManyProgresTahapanInputEnvelope
    connect?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
  }

  export type EnumStatusTahapanFieldUpdateOperationsInput = {
    set?: $Enums.StatusTahapan
  }

  export type TransaksiPengadaanUpdateOneRequiredWithoutProgresTahapanNestedInput = {
    create?: XOR<TransaksiPengadaanCreateWithoutProgresTahapanInput, TransaksiPengadaanUncheckedCreateWithoutProgresTahapanInput>
    connectOrCreate?: TransaksiPengadaanCreateOrConnectWithoutProgresTahapanInput
    upsert?: TransaksiPengadaanUpsertWithoutProgresTahapanInput
    connect?: TransaksiPengadaanWhereUniqueInput
    update?: XOR<XOR<TransaksiPengadaanUpdateToOneWithWhereWithoutProgresTahapanInput, TransaksiPengadaanUpdateWithoutProgresTahapanInput>, TransaksiPengadaanUncheckedUpdateWithoutProgresTahapanInput>
  }

  export type TahapanUpdateOneRequiredWithoutProgresTahapanNestedInput = {
    create?: XOR<TahapanCreateWithoutProgresTahapanInput, TahapanUncheckedCreateWithoutProgresTahapanInput>
    connectOrCreate?: TahapanCreateOrConnectWithoutProgresTahapanInput
    upsert?: TahapanUpsertWithoutProgresTahapanInput
    connect?: TahapanWhereUniqueInput
    update?: XOR<XOR<TahapanUpdateToOneWithWhereWithoutProgresTahapanInput, TahapanUpdateWithoutProgresTahapanInput>, TahapanUncheckedUpdateWithoutProgresTahapanInput>
  }

  export type DokumenProgresTahapanUpdateManyWithoutProgresTahapanNestedInput = {
    create?: XOR<DokumenProgresTahapanCreateWithoutProgresTahapanInput, DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput> | DokumenProgresTahapanCreateWithoutProgresTahapanInput[] | DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput[]
    connectOrCreate?: DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput | DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput[]
    upsert?: DokumenProgresTahapanUpsertWithWhereUniqueWithoutProgresTahapanInput | DokumenProgresTahapanUpsertWithWhereUniqueWithoutProgresTahapanInput[]
    createMany?: DokumenProgresTahapanCreateManyProgresTahapanInputEnvelope
    set?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
    disconnect?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
    delete?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
    connect?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
    update?: DokumenProgresTahapanUpdateWithWhereUniqueWithoutProgresTahapanInput | DokumenProgresTahapanUpdateWithWhereUniqueWithoutProgresTahapanInput[]
    updateMany?: DokumenProgresTahapanUpdateManyWithWhereWithoutProgresTahapanInput | DokumenProgresTahapanUpdateManyWithWhereWithoutProgresTahapanInput[]
    deleteMany?: DokumenProgresTahapanScalarWhereInput | DokumenProgresTahapanScalarWhereInput[]
  }

  export type DokumenProgresTahapanUncheckedUpdateManyWithoutProgresTahapanNestedInput = {
    create?: XOR<DokumenProgresTahapanCreateWithoutProgresTahapanInput, DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput> | DokumenProgresTahapanCreateWithoutProgresTahapanInput[] | DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput[]
    connectOrCreate?: DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput | DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput[]
    upsert?: DokumenProgresTahapanUpsertWithWhereUniqueWithoutProgresTahapanInput | DokumenProgresTahapanUpsertWithWhereUniqueWithoutProgresTahapanInput[]
    createMany?: DokumenProgresTahapanCreateManyProgresTahapanInputEnvelope
    set?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
    disconnect?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
    delete?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
    connect?: DokumenProgresTahapanWhereUniqueInput | DokumenProgresTahapanWhereUniqueInput[]
    update?: DokumenProgresTahapanUpdateWithWhereUniqueWithoutProgresTahapanInput | DokumenProgresTahapanUpdateWithWhereUniqueWithoutProgresTahapanInput[]
    updateMany?: DokumenProgresTahapanUpdateManyWithWhereWithoutProgresTahapanInput | DokumenProgresTahapanUpdateManyWithWhereWithoutProgresTahapanInput[]
    deleteMany?: DokumenProgresTahapanScalarWhereInput | DokumenProgresTahapanScalarWhereInput[]
  }

  export type ProgresTahapanCreateNestedOneWithoutDokumenInput = {
    create?: XOR<ProgresTahapanCreateWithoutDokumenInput, ProgresTahapanUncheckedCreateWithoutDokumenInput>
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutDokumenInput
    connect?: ProgresTahapanWhereUniqueInput
  }

  export type ProgresTahapanUpdateOneRequiredWithoutDokumenNestedInput = {
    create?: XOR<ProgresTahapanCreateWithoutDokumenInput, ProgresTahapanUncheckedCreateWithoutDokumenInput>
    connectOrCreate?: ProgresTahapanCreateOrConnectWithoutDokumenInput
    upsert?: ProgresTahapanUpsertWithoutDokumenInput
    connect?: ProgresTahapanWhereUniqueInput
    update?: XOR<XOR<ProgresTahapanUpdateToOneWithWhereWithoutDokumenInput, ProgresTahapanUpdateWithoutDokumenInput>, ProgresTahapanUncheckedUpdateWithoutDokumenInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumStatusTahapanFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusTahapan | EnumStatusTahapanFieldRefInput<$PrismaModel>
    in?: $Enums.StatusTahapan[]
    notIn?: $Enums.StatusTahapan[]
    not?: NestedEnumStatusTahapanFilter<$PrismaModel> | $Enums.StatusTahapan
  }

  export type NestedEnumStatusTahapanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusTahapan | EnumStatusTahapanFieldRefInput<$PrismaModel>
    in?: $Enums.StatusTahapan[]
    notIn?: $Enums.StatusTahapan[]
    not?: NestedEnumStatusTahapanWithAggregatesFilter<$PrismaModel> | $Enums.StatusTahapan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTahapanFilter<$PrismaModel>
    _max?: NestedEnumStatusTahapanFilter<$PrismaModel>
  }

  export type DinasCreateWithoutUsersInput = {
    namaDinas: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programs?: ProgramCreateNestedManyWithoutDinasInput
  }

  export type DinasUncheckedCreateWithoutUsersInput = {
    id?: number
    namaDinas: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programs?: ProgramUncheckedCreateNestedManyWithoutDinasInput
  }

  export type DinasCreateOrConnectWithoutUsersInput = {
    where: DinasWhereUniqueInput
    create: XOR<DinasCreateWithoutUsersInput, DinasUncheckedCreateWithoutUsersInput>
  }

  export type AccessTokenCreateWithoutUserInput = {
    token: string
    expiresAt?: Date | string | null
    revoked?: boolean
    createdAt?: Date | string
  }

  export type AccessTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt?: Date | string | null
    revoked?: boolean
    createdAt?: Date | string
  }

  export type AccessTokenCreateOrConnectWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    create: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput>
  }

  export type AccessTokenCreateManyUserInputEnvelope = {
    data: AccessTokenCreateManyUserInput | AccessTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DinasUpsertWithoutUsersInput = {
    update: XOR<DinasUpdateWithoutUsersInput, DinasUncheckedUpdateWithoutUsersInput>
    create: XOR<DinasCreateWithoutUsersInput, DinasUncheckedCreateWithoutUsersInput>
    where?: DinasWhereInput
  }

  export type DinasUpdateToOneWithWhereWithoutUsersInput = {
    where?: DinasWhereInput
    data: XOR<DinasUpdateWithoutUsersInput, DinasUncheckedUpdateWithoutUsersInput>
  }

  export type DinasUpdateWithoutUsersInput = {
    namaDinas?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUpdateManyWithoutDinasNestedInput
  }

  export type DinasUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaDinas?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUncheckedUpdateManyWithoutDinasNestedInput
  }

  export type AccessTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    update: XOR<AccessTokenUpdateWithoutUserInput, AccessTokenUncheckedUpdateWithoutUserInput>
    create: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput>
  }

  export type AccessTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    data: XOR<AccessTokenUpdateWithoutUserInput, AccessTokenUncheckedUpdateWithoutUserInput>
  }

  export type AccessTokenUpdateManyWithWhereWithoutUserInput = {
    where: AccessTokenScalarWhereInput
    data: XOR<AccessTokenUpdateManyMutationInput, AccessTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type AccessTokenScalarWhereInput = {
    AND?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
    OR?: AccessTokenScalarWhereInput[]
    NOT?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
    id?: IntFilter<"AccessToken"> | number
    token?: StringFilter<"AccessToken"> | string
    userId?: IntFilter<"AccessToken"> | number
    expiresAt?: DateTimeNullableFilter<"AccessToken"> | Date | string | null
    revoked?: BoolFilter<"AccessToken"> | boolean
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
  }

  export type UserCreateWithoutAccessTokensInput = {
    username: string
    password: string
    name?: string | null
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    dinas?: DinasCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAccessTokensInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    role: $Enums.Role
    dinasId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutAccessTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccessTokensInput, UserUncheckedCreateWithoutAccessTokensInput>
  }

  export type UserUpsertWithoutAccessTokensInput = {
    update: XOR<UserUpdateWithoutAccessTokensInput, UserUncheckedUpdateWithoutAccessTokensInput>
    create: XOR<UserCreateWithoutAccessTokensInput, UserUncheckedCreateWithoutAccessTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccessTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccessTokensInput, UserUncheckedUpdateWithoutAccessTokensInput>
  }

  export type UserUpdateWithoutAccessTokensInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dinas?: DinasUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAccessTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    dinasId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutDinasInput = {
    username: string
    password: string
    name?: string | null
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDinasInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDinasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDinasInput, UserUncheckedCreateWithoutDinasInput>
  }

  export type UserCreateManyDinasInputEnvelope = {
    data: UserCreateManyDinasInput | UserCreateManyDinasInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCreateWithoutDinasInput = {
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pengadaan?: TransaksiPengadaanCreateNestedManyWithoutProgramInput
    dokumen?: DokumenProgramCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutDinasInput = {
    id?: number
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pengadaan?: TransaksiPengadaanUncheckedCreateNestedManyWithoutProgramInput
    dokumen?: DokumenProgramUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutDinasInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutDinasInput, ProgramUncheckedCreateWithoutDinasInput>
  }

  export type ProgramCreateManyDinasInputEnvelope = {
    data: ProgramCreateManyDinasInput | ProgramCreateManyDinasInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutDinasInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDinasInput, UserUncheckedUpdateWithoutDinasInput>
    create: XOR<UserCreateWithoutDinasInput, UserUncheckedCreateWithoutDinasInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDinasInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDinasInput, UserUncheckedUpdateWithoutDinasInput>
  }

  export type UserUpdateManyWithWhereWithoutDinasInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDinasInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    dinasId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ProgramUpsertWithWhereUniqueWithoutDinasInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutDinasInput, ProgramUncheckedUpdateWithoutDinasInput>
    create: XOR<ProgramCreateWithoutDinasInput, ProgramUncheckedCreateWithoutDinasInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutDinasInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutDinasInput, ProgramUncheckedUpdateWithoutDinasInput>
  }

  export type ProgramUpdateManyWithWhereWithoutDinasInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutDinasInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    OR?: ProgramScalarWhereInput[]
    NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    id?: IntFilter<"Program"> | number
    namaProgram?: StringFilter<"Program"> | string
    slug?: StringFilter<"Program"> | string
    anggaran?: BigIntFilter<"Program"> | bigint | number
    isPrioritas?: BoolFilter<"Program"> | boolean
    dinasId?: IntFilter<"Program"> | number
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
  }

  export type DinasCreateWithoutProgramsInput = {
    namaDinas: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDinasInput
  }

  export type DinasUncheckedCreateWithoutProgramsInput = {
    id?: number
    namaDinas: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDinasInput
  }

  export type DinasCreateOrConnectWithoutProgramsInput = {
    where: DinasWhereUniqueInput
    create: XOR<DinasCreateWithoutProgramsInput, DinasUncheckedCreateWithoutProgramsInput>
  }

  export type TransaksiPengadaanCreateWithoutProgramInput = {
    namaTransaksi: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pengadaan: PengadaanCreateNestedOneWithoutTransaksiInput
    progresTahapan?: ProgresTahapanCreateNestedManyWithoutTransaksiInput
  }

  export type TransaksiPengadaanUncheckedCreateWithoutProgramInput = {
    id?: number
    namaTransaksi: string
    title: string
    pengadaanId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    progresTahapan?: ProgresTahapanUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type TransaksiPengadaanCreateOrConnectWithoutProgramInput = {
    where: TransaksiPengadaanWhereUniqueInput
    create: XOR<TransaksiPengadaanCreateWithoutProgramInput, TransaksiPengadaanUncheckedCreateWithoutProgramInput>
  }

  export type TransaksiPengadaanCreateManyProgramInputEnvelope = {
    data: TransaksiPengadaanCreateManyProgramInput | TransaksiPengadaanCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type DokumenProgramCreateWithoutProgramInput = {
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgramUncheckedCreateWithoutProgramInput = {
    id?: number
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgramCreateOrConnectWithoutProgramInput = {
    where: DokumenProgramWhereUniqueInput
    create: XOR<DokumenProgramCreateWithoutProgramInput, DokumenProgramUncheckedCreateWithoutProgramInput>
  }

  export type DokumenProgramCreateManyProgramInputEnvelope = {
    data: DokumenProgramCreateManyProgramInput | DokumenProgramCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type DinasUpsertWithoutProgramsInput = {
    update: XOR<DinasUpdateWithoutProgramsInput, DinasUncheckedUpdateWithoutProgramsInput>
    create: XOR<DinasCreateWithoutProgramsInput, DinasUncheckedCreateWithoutProgramsInput>
    where?: DinasWhereInput
  }

  export type DinasUpdateToOneWithWhereWithoutProgramsInput = {
    where?: DinasWhereInput
    data: XOR<DinasUpdateWithoutProgramsInput, DinasUncheckedUpdateWithoutProgramsInput>
  }

  export type DinasUpdateWithoutProgramsInput = {
    namaDinas?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDinasNestedInput
  }

  export type DinasUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaDinas?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDinasNestedInput
  }

  export type TransaksiPengadaanUpsertWithWhereUniqueWithoutProgramInput = {
    where: TransaksiPengadaanWhereUniqueInput
    update: XOR<TransaksiPengadaanUpdateWithoutProgramInput, TransaksiPengadaanUncheckedUpdateWithoutProgramInput>
    create: XOR<TransaksiPengadaanCreateWithoutProgramInput, TransaksiPengadaanUncheckedCreateWithoutProgramInput>
  }

  export type TransaksiPengadaanUpdateWithWhereUniqueWithoutProgramInput = {
    where: TransaksiPengadaanWhereUniqueInput
    data: XOR<TransaksiPengadaanUpdateWithoutProgramInput, TransaksiPengadaanUncheckedUpdateWithoutProgramInput>
  }

  export type TransaksiPengadaanUpdateManyWithWhereWithoutProgramInput = {
    where: TransaksiPengadaanScalarWhereInput
    data: XOR<TransaksiPengadaanUpdateManyMutationInput, TransaksiPengadaanUncheckedUpdateManyWithoutProgramInput>
  }

  export type TransaksiPengadaanScalarWhereInput = {
    AND?: TransaksiPengadaanScalarWhereInput | TransaksiPengadaanScalarWhereInput[]
    OR?: TransaksiPengadaanScalarWhereInput[]
    NOT?: TransaksiPengadaanScalarWhereInput | TransaksiPengadaanScalarWhereInput[]
    id?: IntFilter<"TransaksiPengadaan"> | number
    namaTransaksi?: StringFilter<"TransaksiPengadaan"> | string
    title?: StringFilter<"TransaksiPengadaan"> | string
    programId?: IntFilter<"TransaksiPengadaan"> | number
    pengadaanId?: IntFilter<"TransaksiPengadaan"> | number
    createdAt?: DateTimeFilter<"TransaksiPengadaan"> | Date | string
    updatedAt?: DateTimeFilter<"TransaksiPengadaan"> | Date | string
  }

  export type DokumenProgramUpsertWithWhereUniqueWithoutProgramInput = {
    where: DokumenProgramWhereUniqueInput
    update: XOR<DokumenProgramUpdateWithoutProgramInput, DokumenProgramUncheckedUpdateWithoutProgramInput>
    create: XOR<DokumenProgramCreateWithoutProgramInput, DokumenProgramUncheckedCreateWithoutProgramInput>
  }

  export type DokumenProgramUpdateWithWhereUniqueWithoutProgramInput = {
    where: DokumenProgramWhereUniqueInput
    data: XOR<DokumenProgramUpdateWithoutProgramInput, DokumenProgramUncheckedUpdateWithoutProgramInput>
  }

  export type DokumenProgramUpdateManyWithWhereWithoutProgramInput = {
    where: DokumenProgramScalarWhereInput
    data: XOR<DokumenProgramUpdateManyMutationInput, DokumenProgramUncheckedUpdateManyWithoutProgramInput>
  }

  export type DokumenProgramScalarWhereInput = {
    AND?: DokumenProgramScalarWhereInput | DokumenProgramScalarWhereInput[]
    OR?: DokumenProgramScalarWhereInput[]
    NOT?: DokumenProgramScalarWhereInput | DokumenProgramScalarWhereInput[]
    id?: IntFilter<"DokumenProgram"> | number
    programId?: IntFilter<"DokumenProgram"> | number
    namaFile?: StringFilter<"DokumenProgram"> | string
    fileUrl?: StringFilter<"DokumenProgram"> | string
    createdAt?: DateTimeFilter<"DokumenProgram"> | Date | string
  }

  export type ProgramCreateWithoutDokumenInput = {
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dinas: DinasCreateNestedOneWithoutProgramsInput
    pengadaan?: TransaksiPengadaanCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutDokumenInput = {
    id?: number
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    dinasId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pengadaan?: TransaksiPengadaanUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutDokumenInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutDokumenInput, ProgramUncheckedCreateWithoutDokumenInput>
  }

  export type ProgramUpsertWithoutDokumenInput = {
    update: XOR<ProgramUpdateWithoutDokumenInput, ProgramUncheckedUpdateWithoutDokumenInput>
    create: XOR<ProgramCreateWithoutDokumenInput, ProgramUncheckedCreateWithoutDokumenInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutDokumenInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutDokumenInput, ProgramUncheckedUpdateWithoutDokumenInput>
  }

  export type ProgramUpdateWithoutDokumenInput = {
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dinas?: DinasUpdateOneRequiredWithoutProgramsNestedInput
    pengadaan?: TransaksiPengadaanUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutDokumenInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    dinasId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pengadaan?: TransaksiPengadaanUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type TahapanCreateWithoutPengadaanInput = {
    noUrut: number
    namaTahapan: string
    standarWaktuHari?: number | null
    isWaktuEditable?: boolean
    bobot: number
    progresTahapan?: ProgresTahapanCreateNestedManyWithoutTahapanInput
  }

  export type TahapanUncheckedCreateWithoutPengadaanInput = {
    id?: number
    noUrut: number
    namaTahapan: string
    standarWaktuHari?: number | null
    isWaktuEditable?: boolean
    bobot: number
    progresTahapan?: ProgresTahapanUncheckedCreateNestedManyWithoutTahapanInput
  }

  export type TahapanCreateOrConnectWithoutPengadaanInput = {
    where: TahapanWhereUniqueInput
    create: XOR<TahapanCreateWithoutPengadaanInput, TahapanUncheckedCreateWithoutPengadaanInput>
  }

  export type TahapanCreateManyPengadaanInputEnvelope = {
    data: TahapanCreateManyPengadaanInput | TahapanCreateManyPengadaanInput[]
    skipDuplicates?: boolean
  }

  export type TransaksiPengadaanCreateWithoutPengadaanInput = {
    namaTransaksi: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutPengadaanInput
    progresTahapan?: ProgresTahapanCreateNestedManyWithoutTransaksiInput
  }

  export type TransaksiPengadaanUncheckedCreateWithoutPengadaanInput = {
    id?: number
    namaTransaksi: string
    title: string
    programId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    progresTahapan?: ProgresTahapanUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type TransaksiPengadaanCreateOrConnectWithoutPengadaanInput = {
    where: TransaksiPengadaanWhereUniqueInput
    create: XOR<TransaksiPengadaanCreateWithoutPengadaanInput, TransaksiPengadaanUncheckedCreateWithoutPengadaanInput>
  }

  export type TransaksiPengadaanCreateManyPengadaanInputEnvelope = {
    data: TransaksiPengadaanCreateManyPengadaanInput | TransaksiPengadaanCreateManyPengadaanInput[]
    skipDuplicates?: boolean
  }

  export type TahapanUpsertWithWhereUniqueWithoutPengadaanInput = {
    where: TahapanWhereUniqueInput
    update: XOR<TahapanUpdateWithoutPengadaanInput, TahapanUncheckedUpdateWithoutPengadaanInput>
    create: XOR<TahapanCreateWithoutPengadaanInput, TahapanUncheckedCreateWithoutPengadaanInput>
  }

  export type TahapanUpdateWithWhereUniqueWithoutPengadaanInput = {
    where: TahapanWhereUniqueInput
    data: XOR<TahapanUpdateWithoutPengadaanInput, TahapanUncheckedUpdateWithoutPengadaanInput>
  }

  export type TahapanUpdateManyWithWhereWithoutPengadaanInput = {
    where: TahapanScalarWhereInput
    data: XOR<TahapanUpdateManyMutationInput, TahapanUncheckedUpdateManyWithoutPengadaanInput>
  }

  export type TahapanScalarWhereInput = {
    AND?: TahapanScalarWhereInput | TahapanScalarWhereInput[]
    OR?: TahapanScalarWhereInput[]
    NOT?: TahapanScalarWhereInput | TahapanScalarWhereInput[]
    id?: IntFilter<"Tahapan"> | number
    pengadaanId?: IntFilter<"Tahapan"> | number
    noUrut?: IntFilter<"Tahapan"> | number
    namaTahapan?: StringFilter<"Tahapan"> | string
    standarWaktuHari?: IntNullableFilter<"Tahapan"> | number | null
    isWaktuEditable?: BoolFilter<"Tahapan"> | boolean
    bobot?: IntFilter<"Tahapan"> | number
  }

  export type TransaksiPengadaanUpsertWithWhereUniqueWithoutPengadaanInput = {
    where: TransaksiPengadaanWhereUniqueInput
    update: XOR<TransaksiPengadaanUpdateWithoutPengadaanInput, TransaksiPengadaanUncheckedUpdateWithoutPengadaanInput>
    create: XOR<TransaksiPengadaanCreateWithoutPengadaanInput, TransaksiPengadaanUncheckedCreateWithoutPengadaanInput>
  }

  export type TransaksiPengadaanUpdateWithWhereUniqueWithoutPengadaanInput = {
    where: TransaksiPengadaanWhereUniqueInput
    data: XOR<TransaksiPengadaanUpdateWithoutPengadaanInput, TransaksiPengadaanUncheckedUpdateWithoutPengadaanInput>
  }

  export type TransaksiPengadaanUpdateManyWithWhereWithoutPengadaanInput = {
    where: TransaksiPengadaanScalarWhereInput
    data: XOR<TransaksiPengadaanUpdateManyMutationInput, TransaksiPengadaanUncheckedUpdateManyWithoutPengadaanInput>
  }

  export type PengadaanCreateWithoutTahapanInput = {
    namaPengadaan: string
    transaksi?: TransaksiPengadaanCreateNestedManyWithoutPengadaanInput
  }

  export type PengadaanUncheckedCreateWithoutTahapanInput = {
    id?: number
    namaPengadaan: string
    transaksi?: TransaksiPengadaanUncheckedCreateNestedManyWithoutPengadaanInput
  }

  export type PengadaanCreateOrConnectWithoutTahapanInput = {
    where: PengadaanWhereUniqueInput
    create: XOR<PengadaanCreateWithoutTahapanInput, PengadaanUncheckedCreateWithoutTahapanInput>
  }

  export type ProgresTahapanCreateWithoutTahapanInput = {
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
    transaksi: TransaksiPengadaanCreateNestedOneWithoutProgresTahapanInput
    dokumen?: DokumenProgresTahapanCreateNestedManyWithoutProgresTahapanInput
  }

  export type ProgresTahapanUncheckedCreateWithoutTahapanInput = {
    id?: number
    transaksiId: number
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
    dokumen?: DokumenProgresTahapanUncheckedCreateNestedManyWithoutProgresTahapanInput
  }

  export type ProgresTahapanCreateOrConnectWithoutTahapanInput = {
    where: ProgresTahapanWhereUniqueInput
    create: XOR<ProgresTahapanCreateWithoutTahapanInput, ProgresTahapanUncheckedCreateWithoutTahapanInput>
  }

  export type ProgresTahapanCreateManyTahapanInputEnvelope = {
    data: ProgresTahapanCreateManyTahapanInput | ProgresTahapanCreateManyTahapanInput[]
    skipDuplicates?: boolean
  }

  export type PengadaanUpsertWithoutTahapanInput = {
    update: XOR<PengadaanUpdateWithoutTahapanInput, PengadaanUncheckedUpdateWithoutTahapanInput>
    create: XOR<PengadaanCreateWithoutTahapanInput, PengadaanUncheckedCreateWithoutTahapanInput>
    where?: PengadaanWhereInput
  }

  export type PengadaanUpdateToOneWithWhereWithoutTahapanInput = {
    where?: PengadaanWhereInput
    data: XOR<PengadaanUpdateWithoutTahapanInput, PengadaanUncheckedUpdateWithoutTahapanInput>
  }

  export type PengadaanUpdateWithoutTahapanInput = {
    namaPengadaan?: StringFieldUpdateOperationsInput | string
    transaksi?: TransaksiPengadaanUpdateManyWithoutPengadaanNestedInput
  }

  export type PengadaanUncheckedUpdateWithoutTahapanInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaPengadaan?: StringFieldUpdateOperationsInput | string
    transaksi?: TransaksiPengadaanUncheckedUpdateManyWithoutPengadaanNestedInput
  }

  export type ProgresTahapanUpsertWithWhereUniqueWithoutTahapanInput = {
    where: ProgresTahapanWhereUniqueInput
    update: XOR<ProgresTahapanUpdateWithoutTahapanInput, ProgresTahapanUncheckedUpdateWithoutTahapanInput>
    create: XOR<ProgresTahapanCreateWithoutTahapanInput, ProgresTahapanUncheckedCreateWithoutTahapanInput>
  }

  export type ProgresTahapanUpdateWithWhereUniqueWithoutTahapanInput = {
    where: ProgresTahapanWhereUniqueInput
    data: XOR<ProgresTahapanUpdateWithoutTahapanInput, ProgresTahapanUncheckedUpdateWithoutTahapanInput>
  }

  export type ProgresTahapanUpdateManyWithWhereWithoutTahapanInput = {
    where: ProgresTahapanScalarWhereInput
    data: XOR<ProgresTahapanUpdateManyMutationInput, ProgresTahapanUncheckedUpdateManyWithoutTahapanInput>
  }

  export type ProgresTahapanScalarWhereInput = {
    AND?: ProgresTahapanScalarWhereInput | ProgresTahapanScalarWhereInput[]
    OR?: ProgresTahapanScalarWhereInput[]
    NOT?: ProgresTahapanScalarWhereInput | ProgresTahapanScalarWhereInput[]
    id?: IntFilter<"ProgresTahapan"> | number
    transaksiId?: IntFilter<"ProgresTahapan"> | number
    tahapanId?: IntFilter<"ProgresTahapan"> | number
    status?: EnumStatusTahapanFilter<"ProgresTahapan"> | $Enums.StatusTahapan
    planningTanggalMulai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    planningTanggalSelesai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    aktualTanggalMulai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    aktualTanggalSelesai?: DateTimeNullableFilter<"ProgresTahapan"> | Date | string | null
    keterangan?: StringNullableFilter<"ProgresTahapan"> | string | null
    updatedAt?: DateTimeFilter<"ProgresTahapan"> | Date | string
  }

  export type ProgramCreateWithoutPengadaanInput = {
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dinas: DinasCreateNestedOneWithoutProgramsInput
    dokumen?: DokumenProgramCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutPengadaanInput = {
    id?: number
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    dinasId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dokumen?: DokumenProgramUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutPengadaanInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutPengadaanInput, ProgramUncheckedCreateWithoutPengadaanInput>
  }

  export type PengadaanCreateWithoutTransaksiInput = {
    namaPengadaan: string
    tahapan?: TahapanCreateNestedManyWithoutPengadaanInput
  }

  export type PengadaanUncheckedCreateWithoutTransaksiInput = {
    id?: number
    namaPengadaan: string
    tahapan?: TahapanUncheckedCreateNestedManyWithoutPengadaanInput
  }

  export type PengadaanCreateOrConnectWithoutTransaksiInput = {
    where: PengadaanWhereUniqueInput
    create: XOR<PengadaanCreateWithoutTransaksiInput, PengadaanUncheckedCreateWithoutTransaksiInput>
  }

  export type ProgresTahapanCreateWithoutTransaksiInput = {
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
    tahapan: TahapanCreateNestedOneWithoutProgresTahapanInput
    dokumen?: DokumenProgresTahapanCreateNestedManyWithoutProgresTahapanInput
  }

  export type ProgresTahapanUncheckedCreateWithoutTransaksiInput = {
    id?: number
    tahapanId: number
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
    dokumen?: DokumenProgresTahapanUncheckedCreateNestedManyWithoutProgresTahapanInput
  }

  export type ProgresTahapanCreateOrConnectWithoutTransaksiInput = {
    where: ProgresTahapanWhereUniqueInput
    create: XOR<ProgresTahapanCreateWithoutTransaksiInput, ProgresTahapanUncheckedCreateWithoutTransaksiInput>
  }

  export type ProgresTahapanCreateManyTransaksiInputEnvelope = {
    data: ProgresTahapanCreateManyTransaksiInput | ProgresTahapanCreateManyTransaksiInput[]
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithoutPengadaanInput = {
    update: XOR<ProgramUpdateWithoutPengadaanInput, ProgramUncheckedUpdateWithoutPengadaanInput>
    create: XOR<ProgramCreateWithoutPengadaanInput, ProgramUncheckedCreateWithoutPengadaanInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutPengadaanInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutPengadaanInput, ProgramUncheckedUpdateWithoutPengadaanInput>
  }

  export type ProgramUpdateWithoutPengadaanInput = {
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dinas?: DinasUpdateOneRequiredWithoutProgramsNestedInput
    dokumen?: DokumenProgramUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutPengadaanInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    dinasId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dokumen?: DokumenProgramUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type PengadaanUpsertWithoutTransaksiInput = {
    update: XOR<PengadaanUpdateWithoutTransaksiInput, PengadaanUncheckedUpdateWithoutTransaksiInput>
    create: XOR<PengadaanCreateWithoutTransaksiInput, PengadaanUncheckedCreateWithoutTransaksiInput>
    where?: PengadaanWhereInput
  }

  export type PengadaanUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: PengadaanWhereInput
    data: XOR<PengadaanUpdateWithoutTransaksiInput, PengadaanUncheckedUpdateWithoutTransaksiInput>
  }

  export type PengadaanUpdateWithoutTransaksiInput = {
    namaPengadaan?: StringFieldUpdateOperationsInput | string
    tahapan?: TahapanUpdateManyWithoutPengadaanNestedInput
  }

  export type PengadaanUncheckedUpdateWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaPengadaan?: StringFieldUpdateOperationsInput | string
    tahapan?: TahapanUncheckedUpdateManyWithoutPengadaanNestedInput
  }

  export type ProgresTahapanUpsertWithWhereUniqueWithoutTransaksiInput = {
    where: ProgresTahapanWhereUniqueInput
    update: XOR<ProgresTahapanUpdateWithoutTransaksiInput, ProgresTahapanUncheckedUpdateWithoutTransaksiInput>
    create: XOR<ProgresTahapanCreateWithoutTransaksiInput, ProgresTahapanUncheckedCreateWithoutTransaksiInput>
  }

  export type ProgresTahapanUpdateWithWhereUniqueWithoutTransaksiInput = {
    where: ProgresTahapanWhereUniqueInput
    data: XOR<ProgresTahapanUpdateWithoutTransaksiInput, ProgresTahapanUncheckedUpdateWithoutTransaksiInput>
  }

  export type ProgresTahapanUpdateManyWithWhereWithoutTransaksiInput = {
    where: ProgresTahapanScalarWhereInput
    data: XOR<ProgresTahapanUpdateManyMutationInput, ProgresTahapanUncheckedUpdateManyWithoutTransaksiInput>
  }

  export type TransaksiPengadaanCreateWithoutProgresTahapanInput = {
    namaTransaksi: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutPengadaanInput
    pengadaan: PengadaanCreateNestedOneWithoutTransaksiInput
  }

  export type TransaksiPengadaanUncheckedCreateWithoutProgresTahapanInput = {
    id?: number
    namaTransaksi: string
    title: string
    programId: number
    pengadaanId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransaksiPengadaanCreateOrConnectWithoutProgresTahapanInput = {
    where: TransaksiPengadaanWhereUniqueInput
    create: XOR<TransaksiPengadaanCreateWithoutProgresTahapanInput, TransaksiPengadaanUncheckedCreateWithoutProgresTahapanInput>
  }

  export type TahapanCreateWithoutProgresTahapanInput = {
    noUrut: number
    namaTahapan: string
    standarWaktuHari?: number | null
    isWaktuEditable?: boolean
    bobot: number
    pengadaan: PengadaanCreateNestedOneWithoutTahapanInput
  }

  export type TahapanUncheckedCreateWithoutProgresTahapanInput = {
    id?: number
    pengadaanId: number
    noUrut: number
    namaTahapan: string
    standarWaktuHari?: number | null
    isWaktuEditable?: boolean
    bobot: number
  }

  export type TahapanCreateOrConnectWithoutProgresTahapanInput = {
    where: TahapanWhereUniqueInput
    create: XOR<TahapanCreateWithoutProgresTahapanInput, TahapanUncheckedCreateWithoutProgresTahapanInput>
  }

  export type DokumenProgresTahapanCreateWithoutProgresTahapanInput = {
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput = {
    id?: number
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgresTahapanCreateOrConnectWithoutProgresTahapanInput = {
    where: DokumenProgresTahapanWhereUniqueInput
    create: XOR<DokumenProgresTahapanCreateWithoutProgresTahapanInput, DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput>
  }

  export type DokumenProgresTahapanCreateManyProgresTahapanInputEnvelope = {
    data: DokumenProgresTahapanCreateManyProgresTahapanInput | DokumenProgresTahapanCreateManyProgresTahapanInput[]
    skipDuplicates?: boolean
  }

  export type TransaksiPengadaanUpsertWithoutProgresTahapanInput = {
    update: XOR<TransaksiPengadaanUpdateWithoutProgresTahapanInput, TransaksiPengadaanUncheckedUpdateWithoutProgresTahapanInput>
    create: XOR<TransaksiPengadaanCreateWithoutProgresTahapanInput, TransaksiPengadaanUncheckedCreateWithoutProgresTahapanInput>
    where?: TransaksiPengadaanWhereInput
  }

  export type TransaksiPengadaanUpdateToOneWithWhereWithoutProgresTahapanInput = {
    where?: TransaksiPengadaanWhereInput
    data: XOR<TransaksiPengadaanUpdateWithoutProgresTahapanInput, TransaksiPengadaanUncheckedUpdateWithoutProgresTahapanInput>
  }

  export type TransaksiPengadaanUpdateWithoutProgresTahapanInput = {
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutPengadaanNestedInput
    pengadaan?: PengadaanUpdateOneRequiredWithoutTransaksiNestedInput
  }

  export type TransaksiPengadaanUncheckedUpdateWithoutProgresTahapanInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    pengadaanId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TahapanUpsertWithoutProgresTahapanInput = {
    update: XOR<TahapanUpdateWithoutProgresTahapanInput, TahapanUncheckedUpdateWithoutProgresTahapanInput>
    create: XOR<TahapanCreateWithoutProgresTahapanInput, TahapanUncheckedCreateWithoutProgresTahapanInput>
    where?: TahapanWhereInput
  }

  export type TahapanUpdateToOneWithWhereWithoutProgresTahapanInput = {
    where?: TahapanWhereInput
    data: XOR<TahapanUpdateWithoutProgresTahapanInput, TahapanUncheckedUpdateWithoutProgresTahapanInput>
  }

  export type TahapanUpdateWithoutProgresTahapanInput = {
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
    pengadaan?: PengadaanUpdateOneRequiredWithoutTahapanNestedInput
  }

  export type TahapanUncheckedUpdateWithoutProgresTahapanInput = {
    id?: IntFieldUpdateOperationsInput | number
    pengadaanId?: IntFieldUpdateOperationsInput | number
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
  }

  export type DokumenProgresTahapanUpsertWithWhereUniqueWithoutProgresTahapanInput = {
    where: DokumenProgresTahapanWhereUniqueInput
    update: XOR<DokumenProgresTahapanUpdateWithoutProgresTahapanInput, DokumenProgresTahapanUncheckedUpdateWithoutProgresTahapanInput>
    create: XOR<DokumenProgresTahapanCreateWithoutProgresTahapanInput, DokumenProgresTahapanUncheckedCreateWithoutProgresTahapanInput>
  }

  export type DokumenProgresTahapanUpdateWithWhereUniqueWithoutProgresTahapanInput = {
    where: DokumenProgresTahapanWhereUniqueInput
    data: XOR<DokumenProgresTahapanUpdateWithoutProgresTahapanInput, DokumenProgresTahapanUncheckedUpdateWithoutProgresTahapanInput>
  }

  export type DokumenProgresTahapanUpdateManyWithWhereWithoutProgresTahapanInput = {
    where: DokumenProgresTahapanScalarWhereInput
    data: XOR<DokumenProgresTahapanUpdateManyMutationInput, DokumenProgresTahapanUncheckedUpdateManyWithoutProgresTahapanInput>
  }

  export type DokumenProgresTahapanScalarWhereInput = {
    AND?: DokumenProgresTahapanScalarWhereInput | DokumenProgresTahapanScalarWhereInput[]
    OR?: DokumenProgresTahapanScalarWhereInput[]
    NOT?: DokumenProgresTahapanScalarWhereInput | DokumenProgresTahapanScalarWhereInput[]
    id?: IntFilter<"DokumenProgresTahapan"> | number
    progresTahapanId?: IntFilter<"DokumenProgresTahapan"> | number
    namaFile?: StringFilter<"DokumenProgresTahapan"> | string
    fileUrl?: StringFilter<"DokumenProgresTahapan"> | string
    createdAt?: DateTimeFilter<"DokumenProgresTahapan"> | Date | string
  }

  export type ProgresTahapanCreateWithoutDokumenInput = {
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
    transaksi: TransaksiPengadaanCreateNestedOneWithoutProgresTahapanInput
    tahapan: TahapanCreateNestedOneWithoutProgresTahapanInput
  }

  export type ProgresTahapanUncheckedCreateWithoutDokumenInput = {
    id?: number
    transaksiId: number
    tahapanId: number
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
  }

  export type ProgresTahapanCreateOrConnectWithoutDokumenInput = {
    where: ProgresTahapanWhereUniqueInput
    create: XOR<ProgresTahapanCreateWithoutDokumenInput, ProgresTahapanUncheckedCreateWithoutDokumenInput>
  }

  export type ProgresTahapanUpsertWithoutDokumenInput = {
    update: XOR<ProgresTahapanUpdateWithoutDokumenInput, ProgresTahapanUncheckedUpdateWithoutDokumenInput>
    create: XOR<ProgresTahapanCreateWithoutDokumenInput, ProgresTahapanUncheckedCreateWithoutDokumenInput>
    where?: ProgresTahapanWhereInput
  }

  export type ProgresTahapanUpdateToOneWithWhereWithoutDokumenInput = {
    where?: ProgresTahapanWhereInput
    data: XOR<ProgresTahapanUpdateWithoutDokumenInput, ProgresTahapanUncheckedUpdateWithoutDokumenInput>
  }

  export type ProgresTahapanUpdateWithoutDokumenInput = {
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaksi?: TransaksiPengadaanUpdateOneRequiredWithoutProgresTahapanNestedInput
    tahapan?: TahapanUpdateOneRequiredWithoutProgresTahapanNestedInput
  }

  export type ProgresTahapanUncheckedUpdateWithoutDokumenInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksiId?: IntFieldUpdateOperationsInput | number
    tahapanId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt?: Date | string | null
    revoked?: boolean
    createdAt?: Date | string
  }

  export type AccessTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyDinasInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCreateManyDinasInput = {
    id?: number
    namaProgram: string
    slug: string
    anggaran: bigint | number
    isPrioritas?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutDinasInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDinasInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDinasInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpdateWithoutDinasInput = {
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pengadaan?: TransaksiPengadaanUpdateManyWithoutProgramNestedInput
    dokumen?: DokumenProgramUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutDinasInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pengadaan?: TransaksiPengadaanUncheckedUpdateManyWithoutProgramNestedInput
    dokumen?: DokumenProgramUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutDinasInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaProgram?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    anggaran?: BigIntFieldUpdateOperationsInput | bigint | number
    isPrioritas?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransaksiPengadaanCreateManyProgramInput = {
    id?: number
    namaTransaksi: string
    title: string
    pengadaanId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DokumenProgramCreateManyProgramInput = {
    id?: number
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type TransaksiPengadaanUpdateWithoutProgramInput = {
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pengadaan?: PengadaanUpdateOneRequiredWithoutTransaksiNestedInput
    progresTahapan?: ProgresTahapanUpdateManyWithoutTransaksiNestedInput
  }

  export type TransaksiPengadaanUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pengadaanId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progresTahapan?: ProgresTahapanUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type TransaksiPengadaanUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pengadaanId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgramUpdateWithoutProgramInput = {
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgramUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgramUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TahapanCreateManyPengadaanInput = {
    id?: number
    noUrut: number
    namaTahapan: string
    standarWaktuHari?: number | null
    isWaktuEditable?: boolean
    bobot: number
  }

  export type TransaksiPengadaanCreateManyPengadaanInput = {
    id?: number
    namaTransaksi: string
    title: string
    programId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TahapanUpdateWithoutPengadaanInput = {
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
    progresTahapan?: ProgresTahapanUpdateManyWithoutTahapanNestedInput
  }

  export type TahapanUncheckedUpdateWithoutPengadaanInput = {
    id?: IntFieldUpdateOperationsInput | number
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
    progresTahapan?: ProgresTahapanUncheckedUpdateManyWithoutTahapanNestedInput
  }

  export type TahapanUncheckedUpdateManyWithoutPengadaanInput = {
    id?: IntFieldUpdateOperationsInput | number
    noUrut?: IntFieldUpdateOperationsInput | number
    namaTahapan?: StringFieldUpdateOperationsInput | string
    standarWaktuHari?: NullableIntFieldUpdateOperationsInput | number | null
    isWaktuEditable?: BoolFieldUpdateOperationsInput | boolean
    bobot?: IntFieldUpdateOperationsInput | number
  }

  export type TransaksiPengadaanUpdateWithoutPengadaanInput = {
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutPengadaanNestedInput
    progresTahapan?: ProgresTahapanUpdateManyWithoutTransaksiNestedInput
  }

  export type TransaksiPengadaanUncheckedUpdateWithoutPengadaanInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progresTahapan?: ProgresTahapanUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type TransaksiPengadaanUncheckedUpdateManyWithoutPengadaanInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaTransaksi?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresTahapanCreateManyTahapanInput = {
    id?: number
    transaksiId: number
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
  }

  export type ProgresTahapanUpdateWithoutTahapanInput = {
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaksi?: TransaksiPengadaanUpdateOneRequiredWithoutProgresTahapanNestedInput
    dokumen?: DokumenProgresTahapanUpdateManyWithoutProgresTahapanNestedInput
  }

  export type ProgresTahapanUncheckedUpdateWithoutTahapanInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksiId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dokumen?: DokumenProgresTahapanUncheckedUpdateManyWithoutProgresTahapanNestedInput
  }

  export type ProgresTahapanUncheckedUpdateManyWithoutTahapanInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksiId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgresTahapanCreateManyTransaksiInput = {
    id?: number
    tahapanId: number
    status?: $Enums.StatusTahapan
    planningTanggalMulai?: Date | string | null
    planningTanggalSelesai?: Date | string | null
    aktualTanggalMulai?: Date | string | null
    aktualTanggalSelesai?: Date | string | null
    keterangan?: string | null
    updatedAt?: Date | string
  }

  export type ProgresTahapanUpdateWithoutTransaksiInput = {
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tahapan?: TahapanUpdateOneRequiredWithoutProgresTahapanNestedInput
    dokumen?: DokumenProgresTahapanUpdateManyWithoutProgresTahapanNestedInput
  }

  export type ProgresTahapanUncheckedUpdateWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    tahapanId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dokumen?: DokumenProgresTahapanUncheckedUpdateManyWithoutProgresTahapanNestedInput
  }

  export type ProgresTahapanUncheckedUpdateManyWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    tahapanId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusTahapanFieldUpdateOperationsInput | $Enums.StatusTahapan
    planningTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planningTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalMulai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aktualTanggalSelesai?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgresTahapanCreateManyProgresTahapanInput = {
    id?: number
    namaFile: string
    fileUrl: string
    createdAt?: Date | string
  }

  export type DokumenProgresTahapanUpdateWithoutProgresTahapanInput = {
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgresTahapanUncheckedUpdateWithoutProgresTahapanInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DokumenProgresTahapanUncheckedUpdateManyWithoutProgresTahapanInput = {
    id?: IntFieldUpdateOperationsInput | number
    namaFile?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DinasCountOutputTypeDefaultArgs instead
     */
    export type DinasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DinasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramCountOutputTypeDefaultArgs instead
     */
    export type ProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PengadaanCountOutputTypeDefaultArgs instead
     */
    export type PengadaanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PengadaanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TahapanCountOutputTypeDefaultArgs instead
     */
    export type TahapanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TahapanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransaksiPengadaanCountOutputTypeDefaultArgs instead
     */
    export type TransaksiPengadaanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransaksiPengadaanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgresTahapanCountOutputTypeDefaultArgs instead
     */
    export type ProgresTahapanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgresTahapanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccessTokenDefaultArgs instead
     */
    export type AccessTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccessTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DinasDefaultArgs instead
     */
    export type DinasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DinasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramDefaultArgs instead
     */
    export type ProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DokumenProgramDefaultArgs instead
     */
    export type DokumenProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DokumenProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PengadaanDefaultArgs instead
     */
    export type PengadaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PengadaanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TahapanDefaultArgs instead
     */
    export type TahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TahapanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransaksiPengadaanDefaultArgs instead
     */
    export type TransaksiPengadaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransaksiPengadaanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgresTahapanDefaultArgs instead
     */
    export type ProgresTahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgresTahapanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DokumenProgresTahapanDefaultArgs instead
     */
    export type DokumenProgresTahapanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DokumenProgresTahapanDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}